import { map as yn } from "nanostores";
if (typeof DelayNode < "u") {
  class t extends DelayNode {
    constructor(n, o, s, c) {
      super(n), o = Math.abs(o), this.delayTime.value = s;
      const a = n.createGain();
      a.gain.value = Math.min(Math.abs(c), 0.995), this.feedback = a.gain;
      const d = n.createGain();
      return d.gain.value = o, this.delayGain = d, this.connect(a), this.connect(d), a.connect(this), this.connect = (l) => d.connect(l), this;
    }
    start(n) {
      this.delayGain.gain.setValueAtTime(this.delayGain.gain.value, n + this.delayTime.value);
    }
  }
  AudioContext.prototype.createFeedbackDelay = function(e, n, o) {
    return new t(this, e, n, o);
  };
}
var jt = {};
jt.generateReverb = function(t, e) {
  for (var n = t.audioContext || new AudioContext(), o = n.sampleRate, s = t.numChannels || 2, c = t.decayTime * 1.5, a = Math.round(t.decayTime * o), d = Math.round(c * o), l = Math.round((t.fadeInTime || 0) * o), i = Math.pow(1 / 1e3, 1 / a), r = n.createBuffer(s, d, o), u = 0; u < s; u++) {
    for (var p = r.getChannelData(u), h = 0; h < d; h++)
      p[h] = Wn() * Math.pow(i, h);
    for (var h = 0; h < l; h++)
      p[h] *= h / l;
  }
  Gn(r, t.lpFreqStart || 0, t.lpFreqEnd || 0, t.decayTime, e);
};
jt.generateGraph = function(t, e, n, o, s) {
  var c = document.createElement("canvas");
  c.width = e, c.height = n;
  var a = c.getContext("2d");
  a.fillStyle = "#000", a.fillRect(0, 0, c.width, c.height), a.fillStyle = "#fff";
  for (var d = e / t.length, l = n / (s - o), i = 0; i < t.length; i++)
    a.fillRect(i * d, n - (t[i] - o) * l, 1, 1);
  return c;
};
var Gn = function(t, e, n, o, s) {
  if (e == 0) {
    s(t);
    return;
  }
  var c = Vn(t), a = new OfflineAudioContext(t.numberOfChannels, c[0].length, t.sampleRate), d = a.createBufferSource();
  d.buffer = t;
  var l = a.createBiquadFilter();
  e = Math.min(e, t.sampleRate / 2), n = Math.min(n, t.sampleRate / 2), l.type = "lowpass", l.Q.value = 1e-4, l.frequency.setValueAtTime(e, 0), l.frequency.linearRampToValueAtTime(n, o), d.connect(l), l.connect(a.destination), d.start(), a.oncomplete = function(i) {
    s(i.renderedBuffer);
  }, a.startRendering(), window.filterNode = l;
}, Vn = function(t) {
  for (var e = [], n = 0; n < t.numberOfChannels; n++)
    e[n] = t.getChannelData(n);
  return e;
}, Wn = function() {
  return Math.random() * 2 - 1;
};
let fe = (t) => console.log(t);
function fn(t, e = "superdough") {
  process.env.NODE_ENV === "development" && console.error(t), N(`[${e}] error: ${t.message}`);
}
const N = (...t) => fe(...t), Fo = (t) => {
  fe = t;
}, Mn = (t) => {
  if (typeof t != "string")
    return [];
  const [e, n = "", o] = t.match(/^([a-gA-G])([#bsf]*)(-?[0-9]*)$/)?.slice(1) || [];
  return e ? [e, n, o ? Number(o) : void 0] : [];
}, xn = { c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11 }, gn = { "#": 1, b: -1, s: 1, f: -1 }, zt = (t, e = 3) => {
  const [n, o, s = e] = Mn(t);
  if (!n)
    throw new Error('not a note: "' + t + '"');
  const c = xn[n.toLowerCase()], a = o?.split("").reduce((d, l) => d + gn[l], 0) || 0;
  return (Number(s) + 1) * 12 + c + a;
}, Me = (t) => Math.pow(2, (t - 69) / 12) * 440, D = (t, e, n) => Math.min(Math.max(t, e), n), Ln = (t) => 12 * Math.log(t / 440) / Math.LN2 + 69, Kn = (t, e) => {
  if (typeof t != "object")
    throw new Error("valueToMidi: expected object value");
  let { freq: n, note: o } = t;
  return typeof n == "number" ? Ln(n) : typeof o == "string" ? zt(o) : typeof o == "number" ? o : e;
};
function O(t, e = 0, n) {
  return isNaN(Number(t)) ? (!n && N(`"${t}" is not a number, falling back to ${e}`, "warning"), e) : t;
}
const xe = (t, e) => (t % e + e) % e, he = (t, e) => xe(Math.round(O(t, 0)), e);
function zn(t, e) {
  return t / e;
}
function ge(t, e) {
  const { s: n, n: o = 0 } = t;
  let s = Kn(t, 36), c = s - 36, a, d = 0;
  if (Array.isArray(e))
    d = he(o, e.length), a = e[d];
  else {
    const i = (u) => zt(u) - s, r = Object.keys(e).filter((u) => !u.startsWith("_")).reduce(
      (u, p, h) => !u || Math.abs(i(p)) < Math.abs(i(u)) ? p : u,
      null
    );
    c = -i(r), d = he(o, e[r].length), a = e[r][d];
  }
  const l = `${n}:${d}`;
  return { transpose: c, url: a, index: d, midi: s, label: l };
}
typeof AudioContext < "u" && (AudioContext.prototype.adjustLength = function(t, e, n = 1, o = 0) {
  const s = Math.floor(D(o, 0, 1) * e.length), c = e.sampleRate * t, a = this.createBuffer(e.numberOfChannels, e.length, e.sampleRate);
  for (let d = 0; d < e.numberOfChannels; d++) {
    let l = e.getChannelData(d), i = a.getChannelData(d);
    for (let r = 0; r < c; r++) {
      let u = (s + r * Math.abs(n)) % l.length;
      n < 1 && (u = u * -1), i[r] = l.at(u) || 0;
    }
  }
  return a;
}, AudioContext.prototype.createReverb = function(t, e, n, o, s, c, a) {
  const d = this.createConvolver();
  return d.generate = (l = 2, i = 0.1, r = 15e3, u = 1e3, p, h, m) => {
    d.duration = l, d.fade = i, d.lp = r, d.dim = u, d.ir = p, d.irspeed = h, d.irbegin = m, p ? d.buffer = this.adjustLength(l, p, h, m) : jt.generateReverb(
      {
        audioContext: this,
        numChannels: 2,
        decayTime: l,
        fadeInTime: i,
        lpFreqStart: r,
        lpFreqEnd: u
      },
      (b) => {
        d.buffer = b;
      }
    );
  }, d.generate(t, e, n, o, s, c, a), d;
});
var pe = {
  a: { freqs: [660, 1120, 2750, 3e3, 3350], gains: [1, 0.5012, 0.0708, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  e: { freqs: [440, 1800, 2700, 3e3, 3300], gains: [1, 0.1995, 0.1259, 0.1, 0.1], qs: [70, 80, 100, 120, 120] },
  i: { freqs: [270, 1850, 2900, 3350, 3590], gains: [1, 0.0631, 0.0631, 0.0158, 0.0158], qs: [40, 90, 100, 120, 120] },
  o: { freqs: [430, 820, 2700, 3e3, 3300], gains: [1, 0.3162, 0.0501, 0.0794, 0.01995], qs: [40, 80, 100, 120, 120] },
  u: { freqs: [370, 630, 2750, 3e3, 3400], gains: [1, 0.1, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  ae: { freqs: [650, 1515, 2400, 3e3, 3350], gains: [1, 0.5, 0.1008, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  aa: { freqs: [560, 900, 2570, 3e3, 3300], gains: [1, 0.5, 0.0708, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  oe: { freqs: [500, 1430, 2300, 3e3, 3300], gains: [1, 0.2, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  ue: { freqs: [250, 1750, 2150, 3200, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  y: { freqs: [400, 1460, 2400, 3e3, 3300], gains: [1, 0.2, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  uh: { freqs: [600, 1250, 2100, 3100, 3500], gains: [1, 0.3, 0.0608, 0.0316, 0.01995], qs: [40, 70, 100, 120, 130] },
  un: { freqs: [500, 1240, 2280, 3e3, 3500], gains: [1, 0.1, 0.1708, 0.0216, 0.02995], qs: [40, 60, 100, 120, 120] },
  en: { freqs: [600, 1480, 2450, 3200, 3300], gains: [1, 0.15, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  an: { freqs: [700, 1050, 2500, 3e3, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  on: { freqs: [500, 1080, 2350, 3e3, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  get æ() {
    return this.ae;
  },
  get ø() {
    return this.oe;
  },
  get ɑ() {
    return this.aa;
  },
  get å() {
    return this.aa;
  },
  get ö() {
    return this.oe;
  },
  get ü() {
    return this.ue;
  },
  get ı() {
    return this.y;
  }
};
if (typeof GainNode < "u") {
  class t extends GainNode {
    constructor(n, o) {
      if (super(n), !pe[o])
        throw new Error("vowel: unknown vowel " + o);
      const { gains: s, qs: c, freqs: a } = pe[o], d = n.createGain();
      for (let l = 0; l < 5; l++) {
        const i = n.createGain();
        i.gain.value = s[l];
        const r = n.createBiquadFilter();
        r.type = "bandpass", r.Q.value = c[l], r.frequency.value = a[l], this.connect(r), r.connect(i), i.connect(d);
      }
      return d.gain.value = 8, this.connect = (l) => d.connect(l), this;
    }
  }
  AudioContext.prototype.createVowelFilter = function(e) {
    return new t(this, e);
  };
}
const Tn = "data:text/javascript;base64,dmFyIF89ZnVuY3Rpb24oQyl7InVzZSBzdHJpY3QiO3ZhciBUZT1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIHllPShDLEQsTCk9PkQgaW4gQz9UZShDLEQse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkx9KTpDW0RdPUw7dmFyIFN0PShDLEQsTCk9PnllKEMsdHlwZW9mIEQhPSJzeW1ib2wiP0QrIiI6RCxMKTtjbGFzcyBMIGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMuc3RhcnRlZD0hMSx0aGlzLm5iSW5wdXRzPXQubnVtYmVyT2ZJbnB1dHMsdGhpcy5uYk91dHB1dHM9dC5udW1iZXJPZk91dHB1dHMsdGhpcy5ibG9ja1NpemU9dC5wcm9jZXNzb3JPcHRpb25zLmJsb2NrU2l6ZSx0aGlzLmhvcFNpemU9MTI4LHRoaXMubmJPdmVybGFwcz10aGlzLmJsb2NrU2l6ZS90aGlzLmhvcFNpemUsdGhpcy5pbnB1dEJ1ZmZlcnM9bmV3IEFycmF5KHRoaXMubmJJbnB1dHMpLHRoaXMuaW5wdXRCdWZmZXJzSGVhZD1uZXcgQXJyYXkodGhpcy5uYklucHV0cyksdGhpcy5pbnB1dEJ1ZmZlcnNUb1NlbmQ9bmV3IEFycmF5KHRoaXMubmJJbnB1dHMpO2ZvcihsZXQgZT0wO2U8dGhpcy5uYklucHV0cztlKyspdGhpcy5hbGxvY2F0ZUlucHV0Q2hhbm5lbHMoZSwxKTt0aGlzLm91dHB1dEJ1ZmZlcnM9bmV3IEFycmF5KHRoaXMubmJPdXRwdXRzKSx0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlPW5ldyBBcnJheSh0aGlzLm5iT3V0cHV0cyk7Zm9yKGxldCBlPTA7ZTx0aGlzLm5iT3V0cHV0cztlKyspdGhpcy5hbGxvY2F0ZU91dHB1dENoYW5uZWxzKGUsMSl9cmVhbGxvY2F0ZUNoYW5uZWxzSWZOZWVkZWQodCxlKXtmb3IobGV0IHM9MDtzPHRoaXMubmJJbnB1dHM7cysrKXtsZXQgcj10W3NdLmxlbmd0aDtyIT10aGlzLmlucHV0QnVmZmVyc1tzXS5sZW5ndGgmJnRoaXMuYWxsb2NhdGVJbnB1dENoYW5uZWxzKHMscil9Zm9yKGxldCBzPTA7czx0aGlzLm5iT3V0cHV0cztzKyspe2xldCByPWVbc10ubGVuZ3RoO3IhPXRoaXMub3V0cHV0QnVmZmVyc1tzXS5sZW5ndGgmJnRoaXMuYWxsb2NhdGVPdXRwdXRDaGFubmVscyhzLHIpfX1hbGxvY2F0ZUlucHV0Q2hhbm5lbHModCxlKXt0aGlzLmlucHV0QnVmZmVyc1t0XT1uZXcgQXJyYXkoZSk7Zm9yKGxldCBzPTA7czxlO3MrKyl0aGlzLmlucHV0QnVmZmVyc1t0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKzEyOCksdGhpcy5pbnB1dEJ1ZmZlcnNbdF1bc10uZmlsbCgwKTt0aGlzLmlucHV0QnVmZmVyc0hlYWRbdF09bmV3IEFycmF5KGUpLHRoaXMuaW5wdXRCdWZmZXJzVG9TZW5kW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMuaW5wdXRCdWZmZXJzSGVhZFt0XVtzXT10aGlzLmlucHV0QnVmZmVyc1t0XVtzXS5zdWJhcnJheSgwLHRoaXMuYmxvY2tTaXplKSx0aGlzLmlucHV0QnVmZmVyc1RvU2VuZFt0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKX1hbGxvY2F0ZU91dHB1dENoYW5uZWxzKHQsZSl7dGhpcy5vdXRwdXRCdWZmZXJzW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMub3V0cHV0QnVmZmVyc1t0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKSx0aGlzLm91dHB1dEJ1ZmZlcnNbdF1bc10uZmlsbCgwKTt0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMub3V0cHV0QnVmZmVyc1RvUmV0cmlldmVbdF1bc109bmV3IEZsb2F0MzJBcnJheSh0aGlzLmJsb2NrU2l6ZSksdGhpcy5vdXRwdXRCdWZmZXJzVG9SZXRyaWV2ZVt0XVtzXS5maWxsKDApfXJlYWRJbnB1dHModCl7aWYodFswXS5sZW5ndGgmJnRbMF1bMF0ubGVuZ3RoPT0wKXtmb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl0aGlzLmlucHV0QnVmZmVyc1tlXVtzXS5maWxsKDAsdGhpcy5ibG9ja1NpemUpO3JldHVybn1mb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl7bGV0IHI9dFtlXVtzXTt0aGlzLmlucHV0QnVmZmVyc1tlXVtzXS5zZXQocix0aGlzLmJsb2NrU2l6ZSl9fXdyaXRlT3V0cHV0cyh0KXtmb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl7bGV0IHI9dGhpcy5vdXRwdXRCdWZmZXJzW2VdW3NdLnN1YmFycmF5KDAsMTI4KTt0W2VdW3NdLnNldChyKX19c2hpZnRJbnB1dEJ1ZmZlcnMoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJJbnB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5pbnB1dEJ1ZmZlcnNbdF0ubGVuZ3RoO2UrKyl0aGlzLmlucHV0QnVmZmVyc1t0XVtlXS5jb3B5V2l0aGluKDAsMTI4KX1zaGlmdE91dHB1dEJ1ZmZlcnMoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJPdXRwdXRzO3QrKylmb3IobGV0IGU9MDtlPHRoaXMub3V0cHV0QnVmZmVyc1t0XS5sZW5ndGg7ZSsrKXRoaXMub3V0cHV0QnVmZmVyc1t0XVtlXS5jb3B5V2l0aGluKDAsMTI4KSx0aGlzLm91dHB1dEJ1ZmZlcnNbdF1bZV0uc3ViYXJyYXkodGhpcy5ibG9ja1NpemUtMTI4KS5maWxsKDApfXByZXBhcmVJbnB1dEJ1ZmZlcnNUb1NlbmQoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJJbnB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5pbnB1dEJ1ZmZlcnNbdF0ubGVuZ3RoO2UrKyl0aGlzLmlucHV0QnVmZmVyc1RvU2VuZFt0XVtlXS5zZXQodGhpcy5pbnB1dEJ1ZmZlcnNIZWFkW3RdW2VdKX1oYW5kbGVPdXRwdXRCdWZmZXJzVG9SZXRyaWV2ZSgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5uYk91dHB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5vdXRwdXRCdWZmZXJzW3RdLmxlbmd0aDtlKyspZm9yKGxldCBzPTA7czx0aGlzLmJsb2NrU2l6ZTtzKyspdGhpcy5vdXRwdXRCdWZmZXJzW3RdW2VdW3NdKz10aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlW3RdW2VdW3NdL3RoaXMubmJPdmVybGFwc31wcm9jZXNzKHQsZSxzKXtjb25zdCBpPXRbMF1bMF0hPT12b2lkIDA7cmV0dXJuIHRoaXMuc3RhcnRlZCYmIWk/ITE6KHRoaXMuc3RhcnRlZD1pLHRoaXMucmVhbGxvY2F0ZUNoYW5uZWxzSWZOZWVkZWQodCxlKSx0aGlzLnJlYWRJbnB1dHModCksdGhpcy5zaGlmdElucHV0QnVmZmVycygpLHRoaXMucHJlcGFyZUlucHV0QnVmZmVyc1RvU2VuZCgpLHRoaXMucHJvY2Vzc09MQSh0aGlzLmlucHV0QnVmZmVyc1RvU2VuZCx0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlLHMpLHRoaXMuaGFuZGxlT3V0cHV0QnVmZmVyc1RvUmV0cmlldmUoKSx0aGlzLndyaXRlT3V0cHV0cyhlKSx0aGlzLnNoaWZ0T3V0cHV0QnVmZmVycygpLCEwKX1wcm9jZXNzT0xBKHQsZSxzKXtjb25zb2xlLmFzc2VydCghMSwiTm90IG92ZXJyaWRlbiIpfX1jbGFzcyBrdHtjb25zdHJ1Y3Rvcih0KXtpZih0aGlzLnNpemU9dHwwLHRoaXMuc2l6ZTw9MXx8dGhpcy5zaXplJnRoaXMuc2l6ZS0xKXRocm93IG5ldyBFcnJvcigiRkZUIHNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3byBhbmQgYmlnZ2VyIHRoYW4gMSIpO3RoaXMuX2NzaXplPXQ8PDE7Zm9yKHZhciBlPW5ldyBBcnJheSh0aGlzLnNpemUqMikscz0wO3M8ZS5sZW5ndGg7cys9Mil7Y29uc3QgYz1NYXRoLlBJKnMvdGhpcy5zaXplO2Vbc109TWF0aC5jb3MoYyksZVtzKzFdPS1NYXRoLnNpbihjKX10aGlzLnRhYmxlPWU7Zm9yKHZhciByPTAsaT0xO3RoaXMuc2l6ZT5pO2k8PD0xKXIrKzt0aGlzLl93aWR0aD1yJTI9PT0wP3ItMTpyLHRoaXMuX2JpdHJldj1uZXcgQXJyYXkoMTw8dGhpcy5fd2lkdGgpO2Zvcih2YXIgbz0wO288dGhpcy5fYml0cmV2Lmxlbmd0aDtvKyspe3RoaXMuX2JpdHJldltvXT0wO2Zvcih2YXIgYT0wO2E8dGhpcy5fd2lkdGg7YSs9Mil7dmFyIHU9dGhpcy5fd2lkdGgtYS0yO3RoaXMuX2JpdHJldltvXXw9KG8+Pj5hJjMpPDx1fX10aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGwsdGhpcy5faW52PTB9ZnJvbUNvbXBsZXhBcnJheSh0LGUpe2Zvcih2YXIgcz1lfHxuZXcgQXJyYXkodC5sZW5ndGg+Pj4xKSxyPTA7cjx0Lmxlbmd0aDtyKz0yKXNbcj4+PjFdPXRbcl07cmV0dXJuIHN9Y3JlYXRlQ29tcGxleEFycmF5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fY3NpemUpO2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09MDtyZXR1cm4gdH10b0NvbXBsZXhBcnJheSh0LGUpe2Zvcih2YXIgcz1lfHx0aGlzLmNyZWF0ZUNvbXBsZXhBcnJheSgpLHI9MDtyPHMubGVuZ3RoO3IrPTIpc1tyXT10W3I+Pj4xXSxzW3IrMV09MDtyZXR1cm4gc31jb21wbGV0ZVNwZWN0cnVtKHQpe2Zvcih2YXIgZT10aGlzLl9jc2l6ZSxzPWU+Pj4xLHI9MjtyPHM7cis9Mil0W2Utcl09dFtyXSx0W2UtcisxXT0tdFtyKzFdfXRyYW5zZm9ybSh0LGUpe2lmKHQ9PT1lKXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PXQsdGhpcy5fZGF0YT1lLHRoaXMuX2ludj0wLHRoaXMuX3RyYW5zZm9ybTQoKSx0aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGx9cmVhbFRyYW5zZm9ybSh0LGUpe2lmKHQ9PT1lKXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PXQsdGhpcy5fZGF0YT1lLHRoaXMuX2ludj0wLHRoaXMuX3JlYWxUcmFuc2Zvcm00KCksdGhpcy5fb3V0PW51bGwsdGhpcy5fZGF0YT1udWxsfWludmVyc2VUcmFuc2Zvcm0odCxlKXtpZih0PT09ZSl0aHJvdyBuZXcgRXJyb3IoIklucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBtdXN0IGJlIGRpZmZlcmVudCIpO3RoaXMuX291dD10LHRoaXMuX2RhdGE9ZSx0aGlzLl9pbnY9MSx0aGlzLl90cmFuc2Zvcm00KCk7Zm9yKHZhciBzPTA7czx0Lmxlbmd0aDtzKyspdFtzXS89dGhpcy5zaXplO3RoaXMuX291dD1udWxsLHRoaXMuX2RhdGE9bnVsbH1fdHJhbnNmb3JtNCgpe3ZhciB0PXRoaXMuX291dCxlPXRoaXMuX2NzaXplLHM9dGhpcy5fd2lkdGgscj0xPDxzLGk9ZS9yPDwxLG8sYSx1PXRoaXMuX2JpdHJldjtpZihpPT09NClmb3Iobz0wLGE9MDtvPGU7bys9aSxhKyspe2NvbnN0IGQ9dVthXTt0aGlzLl9zaW5nbGVUcmFuc2Zvcm0yKG8sZCxyKX1lbHNlIGZvcihvPTAsYT0wO288ZTtvKz1pLGErKyl7Y29uc3QgZD11W2FdO3RoaXMuX3NpbmdsZVRyYW5zZm9ybTQobyxkLHIpfXZhciBjPXRoaXMuX2ludj8tMToxLGg9dGhpcy50YWJsZTtmb3Iocj4+PTI7cj49MjtyPj49Mil7aT1lL3I8PDE7dmFyIGY9aT4+PjI7Zm9yKG89MDtvPGU7bys9aSlmb3IodmFyIHA9bytmLGw9byxtPTA7bDxwO2wrPTIsbSs9cil7Y29uc3QgZD1sLGI9ZCtmLEk9YitmLHY9SStmLFA9dFtkXSx3PXRbZCsxXSxUPXRbYl0sQj10W2IrMV0sQT10W0ldLHk9dFtJKzFdLE89dFt2XSxxPXRbdisxXSx4PVAsRT13LE49aFttXSxGPWMqaFttKzFdLFY9VCpOLUIqRixrPVQqRitCKk4sUj1oWzIqbV0sWD1jKmhbMiptKzFdLHR0PUEqUi15KlgsZXQ9QSpYK3kqUixzdD1oWzMqbV0scnQ9YypoWzMqbSsxXSxudD1PKnN0LXEqcnQsaXQ9TypydCtxKnN0LG90PXgrdHQsSz1FK2V0LGo9eC10dCxhdD1FLWV0LGN0PVYrbnQsWj1rK2l0LCQ9YyooVi1udCksdXQ9Yyooay1pdCksbHQ9b3QrY3QsZ3Q9SytaLGJ0PW90LWN0LEl0PUstWixfdD1qK3V0LEJ0PWF0LSQsTXQ9ai11dCxQdD1hdCskO3RbZF09bHQsdFtkKzFdPWd0LHRbYl09X3QsdFtiKzFdPUJ0LHRbSV09YnQsdFtJKzFdPUl0LHRbdl09TXQsdFt2KzFdPVB0fX19X3NpbmdsZVRyYW5zZm9ybTIodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LGk9dGhpcy5fZGF0YSxvPWlbZV0sYT1pW2UrMV0sdT1pW2Urc10sYz1pW2UrcysxXSxoPW8rdSxmPWErYyxwPW8tdSxsPWEtYztyW3RdPWgsclt0KzFdPWYsclt0KzJdPXAsclt0KzNdPWx9X3NpbmdsZVRyYW5zZm9ybTQodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LGk9dGhpcy5fZGF0YSxvPXRoaXMuX2ludj8tMToxLGE9cyoyLHU9cyozLGM9aVtlXSxoPWlbZSsxXSxmPWlbZStzXSxwPWlbZStzKzFdLGw9aVtlK2FdLG09aVtlK2ErMV0sZD1pW2UrdV0sYj1pW2UrdSsxXSxJPWMrbCx2PWgrbSxQPWMtbCx3PWgtbSxUPWYrZCxCPXArYixBPW8qKGYtZCkseT1vKihwLWIpLE89SStULHE9ditCLHg9UCt5LEU9dy1BLE49SS1ULEY9di1CLFY9UC15LGs9dytBO3JbdF09TyxyW3QrMV09cSxyW3QrMl09eCxyW3QrM109RSxyW3QrNF09TixyW3QrNV09RixyW3QrNl09VixyW3QrN109a31fcmVhbFRyYW5zZm9ybTQoKXt2YXIgdD10aGlzLl9vdXQsZT10aGlzLl9jc2l6ZSxzPXRoaXMuX3dpZHRoLHI9MTw8cyxpPWUvcjw8MSxvLGEsdT10aGlzLl9iaXRyZXY7aWYoaT09PTQpZm9yKG89MCxhPTA7bzxlO28rPWksYSsrKXtjb25zdCB3dD11W2FdO3RoaXMuX3NpbmdsZVJlYWxUcmFuc2Zvcm0yKG8sd3Q+Pj4xLHI+Pj4xKX1lbHNlIGZvcihvPTAsYT0wO288ZTtvKz1pLGErKyl7Y29uc3Qgd3Q9dVthXTt0aGlzLl9zaW5nbGVSZWFsVHJhbnNmb3JtNChvLHd0Pj4+MSxyPj4+MSl9dmFyIGM9dGhpcy5faW52Py0xOjEsaD10aGlzLnRhYmxlO2ZvcihyPj49MjtyPj0yO3I+Pj0yKXtpPWUvcjw8MTt2YXIgZj1pPj4+MSxwPWY+Pj4xLGw9cD4+PjE7Zm9yKG89MDtvPGU7bys9aSlmb3IodmFyIG09MCxkPTA7bTw9bDttKz0yLGQrPXIpe3ZhciBiPW8rbSxJPWIrcCx2PUkrcCxQPXYrcCx3PXRbYl0sVD10W2IrMV0sQj10W0ldLEE9dFtJKzFdLHk9dFt2XSxPPXRbdisxXSxxPXRbUF0seD10W1ArMV0sRT13LE49VCxGPWhbZF0sVj1jKmhbZCsxXSxrPUIqRi1BKlYsUj1CKlYrQSpGLFg9aFsyKmRdLHR0PWMqaFsyKmQrMV0sZXQ9eSpYLU8qdHQsc3Q9eSp0dCtPKlgscnQ9aFszKmRdLG50PWMqaFszKmQrMV0saXQ9cSpydC14Km50LG90PXEqbnQreCpydCxLPUUrZXQsaj1OK3N0LGF0PUUtZXQsY3Q9Ti1zdCxaPWsraXQsJD1SK290LHV0PWMqKGstaXQpLGx0PWMqKFItb3QpLGd0PUsrWixidD1qKyQsSXQ9YXQrbHQsX3Q9Y3QtdXQ7aWYodFtiXT1ndCx0W2IrMV09YnQsdFtJXT1JdCx0W0krMV09X3QsbT09PTApe3ZhciBCdD1LLVosTXQ9ai0kO3Rbdl09QnQsdFt2KzFdPU10O2NvbnRpbnVlfWlmKG0hPT1sKXt2YXIgUHQ9YXQsbWU9LWN0LHZlPUssZ2U9LWosYmU9LWMqbHQsSWU9LWMqdXQsX2U9LWMqJCxCZT0tYypaLE1lPVB0K2JlLFBlPW1lK0llLHdlPXZlK0JlLFNlPWdlLV9lLEN0PW8rcC1tLEV0PW8rZi1tO3RbQ3RdPU1lLHRbQ3QrMV09UGUsdFtFdF09d2UsdFtFdCsxXT1TZX19fX1fc2luZ2xlUmVhbFRyYW5zZm9ybTIodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LGk9dGhpcy5fZGF0YSxvPWlbZV0sYT1pW2Urc10sdT1vK2EsYz1vLWE7clt0XT11LHJbdCsxXT0wLHJbdCsyXT1jLHJbdCszXT0wfV9zaW5nbGVSZWFsVHJhbnNmb3JtNCh0LGUscyl7Y29uc3Qgcj10aGlzLl9vdXQsaT10aGlzLl9kYXRhLG89dGhpcy5faW52Py0xOjEsYT1zKjIsdT1zKjMsYz1pW2VdLGg9aVtlK3NdLGY9aVtlK2FdLHA9aVtlK3VdLGw9YytmLG09Yy1mLGQ9aCtwLGI9byooaC1wKSxJPWwrZCx2PW0sUD0tYix3PWwtZCxUPW0sQj1iO3JbdF09SSxyW3QrMV09MCxyW3QrMl09dixyW3QrM109UCxyW3QrNF09dyxyW3QrNV09MCxyW3QrNl09VCxyW3QrN109Qn19bGV0IER0PW49PmNvbnNvbGUubG9nKG4pO2NvbnN0IHp0PSguLi5uKT0+RHQoLi4ubikscXQ9KG4sdCxlKT0+TWF0aC5taW4oTWF0aC5tYXgobix0KSxlKSxUdD1uPT5uLygxK24pLFd0PShuLHQpPT4obiV0K3QpJXQsTHQ9KG4sdCk9PigxK3QpKm4vKDErdCpNYXRoLmFicyhuKSksWT0obix0KT0+TWF0aC50YW5oKG4qKDErdCkpLFl0PShuLHQpPT5xdCgoMSt0KSpuLC0xLDEpLHl0PShuLHQpPT57bGV0IGU9KDErLjUqdCkqbjtjb25zdCBzPVd0KGUrMSw0KTtyZXR1cm4gMS1NYXRoLmFicyhzLTIpfSxIdD0obix0KT0+TWF0aC5zaW4oTWF0aC5QSS8yKnl0KG4sdCkpLFV0PShuLHQpPT57Y29uc3QgZT1UdChNYXRoLmxvZzFwKHQpKSxzPShuLWUvMypuKm4qbikvKDEtZS8zKTtyZXR1cm4gWShzLHQpfSxBdD0obix0LGU9ITEpPT57Y29uc3Qgcz0xKzIqdCxpPS4wNypUdChNYXRoLmxvZzFwKHQpKSxvPVkobitpLDIqdCksYT1ZKGU/aTotbitpLDIqdCksdT1vLWEsYz0xL01hdGguY29zaChzKmkpLGg9YypjLGY9TWF0aC5tYXgoMWUtOCwoZT8xOjIpKnMqaCk7cmV0dXJuIFkodS9mLHQpfSxPdD17c2N1cnZlOkx0LHNvZnQ6WSxoYXJkOll0LGN1YmljOlV0LGRpb2RlOkF0LGFzeW06KG4sdCk9PkF0KG4sdCwhMCksZm9sZDp5dCxzaW5lZm9sZDpIdCxjaGVieXNoZXY6KG4sdCk9Pntjb25zdCBlPTEwKk1hdGgubG9nMXAodCk7bGV0IHM9MSxyPW4saSxvPTA7Zm9yKGxldCBhPTE7YTw2NDthKyspe2lmKGE8Mil7bys9YT09MD9zOnI7Y29udGludWV9aT0yKm4qcy1yLHI9cyxzPWksYSUyPT09MCYmKG8rPU1hdGgubWluKDEuMyplL2EsMikqaSl9cmV0dXJuIFkobyxlLzIwKX19LEc9T2JqZWN0LmZyZWV6ZShPYmplY3Qua2V5cyhPdCkpLEt0PW49PntsZXQgdD1uO3R5cGVvZiBuPT0ic3RyaW5nIiYmKHQ9Ry5pbmRleE9mKG4pLHQ9PT0tMSYmKHp0KGBbc3VwZXJkb3VnaF0gQ291bGQgbm90IGZpbmQgd2F2ZXNoYXBpbmcgYWxnb3JpdGhtICR7bn0uCiAgICAgICAgQXZhaWxhYmxlIG9wdGlvbnMgYXJlICR7Ry5qb2luKCIsICIpfS4KICAgICAgICBEZWZhdWx0aW5nIHRvICR7R1swXX0uYCksdD0wKSk7Y29uc3QgZT1HW3QlRy5sZW5ndGhdO3JldHVybiBPdFtlXX0sTT0obix0LGUpPT5NYXRoLm1pbihNYXRoLm1heChuLHQpLGUpLHh0PShuLHQpPT4obiV0K3QpJXQsanQ9KG4sdCxlKT0+ZSoodC1uKStuLFM9KG4sdCk9Pm5bdF0/P25bMF0sVz1uPT5uLU1hdGguZmxvb3IobiksZnQ9bj0+bnwwLE50PShuLHQsZSk9Pm48Mj8wOmp0KC10Ki41LHQqLjUsZS8obi0xKSksSD0obix0KT0+bipNYXRoLnBvdygyLHQvMTIpO2Z1bmN0aW9uIEZ0KG4sdD0xKXtyZXR1cm4gbj49dD9uLT10Om48MCYmKG4rPXQpLG59Y29uc3QgVT0xMjg7ZnVuY3Rpb24gWnQobix0KXtyZXR1cm4gdD1NYXRoLm1pbih0LDEtdCksbjx0PyhuLz10LG4rbi1uKm4tMSk6bj4xLXQ/KG49KG4tMSkvdCxuKm4rbituKzEpOjB9Y29uc3QgcHQ9e3RyaShuLHQ9LjUpe2NvbnN0IGU9MS10O3JldHVybiBuPj10PzEvZS1uL2U6bi90fSxzaW5lKG4pe3JldHVybiBNYXRoLnNpbihNYXRoLlBJKjIqbikqLjUrLjV9LHJhbXAobil7cmV0dXJuIG59LHNhdyhuKXtyZXR1cm4gMS1ufSxzcXVhcmUobix0PS41KXtyZXR1cm4gbj49dD8wOjF9LGN1c3RvbShuLHQ9WzAsMV0pe2NvbnN0IGU9dC5sZW5ndGgtMSxzPU1hdGguZmxvb3IobiplKSxyPTEvZSxpPU0odFtzXSwwLDEpLGE9TSh0W3MrMV0sMCwxKSx1PWksYz0wLGg9cjtyZXR1cm4oYS11KS8oaC1jKSoobi1yKnMpK2l9LHNhd2JsZXAobix0KXtyZXR1cm4gMipuLTEtWnQobix0KX19O2Z1bmN0aW9uIFEobix0KXtyZXR1cm4gdC5sZW5ndGg+MT90W25dOnRbMF19Y29uc3QgJHQ9T2JqZWN0LmtleXMocHQpO2NsYXNzIEd0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImJlZ2luIixkZWZhdWx0VmFsdWU6MH0se25hbWU6InRpbWUiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MH0se25hbWU6ImZyZXF1ZW5jeSIsZGVmYXVsdFZhbHVlOi41fSx7bmFtZToic2tldyIsZGVmYXVsdFZhbHVlOi41fSx7bmFtZToiZGVwdGgiLGRlZmF1bHRWYWx1ZToxfSx7bmFtZToicGhhc2VvZmZzZXQiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToic2hhcGUiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToiY3VydmUiLGRlZmF1bHRWYWx1ZToxfSx7bmFtZToiZGNvZmZzZXQiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToibWluIixkZWZhdWx0VmFsdWU6MH0se25hbWU6Im1heCIsZGVmYXVsdFZhbHVlOjF9XX1jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5waGFzZX1pbmNyZW1lbnRQaGFzZSh0KXt0aGlzLnBoYXNlKz10LHRoaXMucGhhc2U+MSYmKHRoaXMucGhhc2U9dGhpcy5waGFzZS0xKX1wcm9jZXNzKHQsZSxzKXtjb25zdCByPXMuYmVnaW5bMF07aWYoY3VycmVudFRpbWU+PXMuZW5kWzBdKXJldHVybiExO2lmKGN1cnJlbnRUaW1lPD1yKXJldHVybiEwO2NvbnN0IGk9ZVswXSxvPXMuZnJlcXVlbmN5WzBdLGE9cy50aW1lWzBdLHU9cy5kZXB0aFswXSxjPXMuc2tld1swXSxoPXMucGhhc2VvZmZzZXRbMF0sZj1zLmN1cnZlWzBdLHA9cy5kY29mZnNldFswXSxsPXMubWluWzBdLG09cy5tYXhbMF0sZD0kdFtzLnNoYXBlWzBdXSxiPWlbMF0ubGVuZ3RoPz8wO3RoaXMucGhhc2U9PW51bGwmJih0aGlzLnBoYXNlPXh0KGEqbytoLDEpKTtjb25zdCBJPW8vc2FtcGxlUmF0ZTtmb3IobGV0IHY9MDt2PGI7disrKXtmb3IobGV0IFA9MDtQPGkubGVuZ3RoO1ArKyl7bGV0IHc9KHB0W2RdKHRoaXMucGhhc2UsYykrcCkqdTt3PU1hdGgucG93KHcsZiksaVtQXVt2XT1NKHcsbCxtKX10aGlzLmluY3JlbWVudFBoYXNlKEkpfXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigibGZvLXByb2Nlc3NvciIsR3QpO2NsYXNzIFF0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImNvYXJzZSIsZGVmYXVsdFZhbHVlOjF9XX1jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5zdGFydGVkPSExfXByb2Nlc3ModCxlLHMpe2NvbnN0IHI9dFswXSxpPWVbMF0sbz1yWzBdIT09dm9pZCAwO2lmKHRoaXMuc3RhcnRlZCYmIW8pcmV0dXJuITE7dGhpcy5zdGFydGVkPW87bGV0IGE9cy5jb2Fyc2VbMF0/PzA7YT1NYXRoLm1heCgxLGEpO2ZvcihsZXQgdT0wO3U8VTt1KyspZm9yKGxldCBjPTA7YzxyLmxlbmd0aDtjKyspaVtjXVt1XT11JWE9PT0wP3JbY11bdV06aVtjXVt1LTFdO3JldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigiY29hcnNlLXByb2Nlc3NvciIsUXQpO2NsYXNzIEp0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImNydXNoIixkZWZhdWx0VmFsdWU6MH1dfWNvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnN0YXJ0ZWQ9ITF9cHJvY2Vzcyh0LGUscyl7Y29uc3Qgcj10WzBdLGk9ZVswXSxvPXJbMF0hPT12b2lkIDA7aWYodGhpcy5zdGFydGVkJiYhbylyZXR1cm4hMTt0aGlzLnN0YXJ0ZWQ9bztsZXQgYT1zLmNydXNoWzBdPz84O2E9TWF0aC5tYXgoMSxhKTtmb3IobGV0IHU9MDt1PFU7dSsrKWZvcihsZXQgYz0wO2M8ci5sZW5ndGg7YysrKXtjb25zdCBoPU1hdGgucG93KDIsYS0xKTtpW2NdW3VdPU1hdGgucm91bmQocltjXVt1XSpoKS9ofXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigiY3J1c2gtcHJvY2Vzc29yIixKdCk7Y2xhc3MgWHQgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToic2hhcGUiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToicG9zdGdhaW4iLGRlZmF1bHRWYWx1ZToxfV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuc3RhcnRlZD0hMX1wcm9jZXNzKHQsZSxzKXtjb25zdCByPXRbMF0saT1lWzBdLG89clswXSE9PXZvaWQgMDtpZih0aGlzLnN0YXJ0ZWQmJiFvKXJldHVybiExO3RoaXMuc3RhcnRlZD1vO2xldCBhPXMuc2hhcGVbMF07YT1hPDE/YTouOTk5OTk5OTk5NixhPTIqYS8oMS1hKTtjb25zdCB1PU1hdGgubWF4KC4wMDEsTWF0aC5taW4oMSxzLnBvc3RnYWluWzBdKSk7Zm9yKGxldCBjPTA7YzxVO2MrKylmb3IobGV0IGg9MDtoPHIubGVuZ3RoO2grKylpW2hdW2NdPSgxK2EpKnJbaF1bY10vKDErYSpNYXRoLmFicyhyW2hdW2NdKSkqdTtyZXR1cm4hMH19cmVnaXN0ZXJQcm9jZXNzb3IoInNoYXBlLXByb2Nlc3NvciIsWHQpO2NsYXNzIFZ0e2NvbnN0cnVjdG9yKCl7U3QodGhpcywiczAiLDApO1N0KHRoaXMsInMxIiwwKX11cGRhdGUodCxlLHM9MCl7cz1NKHMsMCwxKSxlPU0oZSwwLHNhbXBsZVJhdGUvMi0xKTtjb25zdCByPU0oMipNYXRoLnNpbihlKihkdC9zYW1wbGVSYXRlKSksMCwxLjE0KSxvPTEtTWF0aC5wb3coLjUsKHMrLjEyNSkvLjEyNSkqcjtyZXR1cm4gdGhpcy5zMD1vKnRoaXMuczAtcip0aGlzLnMxK3IqdCx0aGlzLnMxPW8qdGhpcy5zMStyKnRoaXMuczAsdGhpcy5zMX19Y2xhc3MgdGUgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToidmFsdWUiLGRlZmF1bHRWYWx1ZTouNX1dfWNvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmZpbHRlcnM9W25ldyBWdCxuZXcgVnRdfXByb2Nlc3ModCxlLHMpe2NvbnN0IHI9dFswXSxpPWVbMF0sbz1yWzBdIT09dm9pZCAwO3RoaXMuc3RhcnRlZD1vO2NvbnN0IGE9TShzLnZhbHVlWzBdLDAsMSk7bGV0IHU9Im5vbmUiLGMsaD0xO2E+LjUxPyh1PSJoaXBhc3MiLGg9KGEtLjUpKjIpOmE8LjQ5JiYodT0ibG9wYXNzIixoPWEqMiksYz1NYXRoLnBvdyhoKjExLDQpO2ZvcihsZXQgZj0wO2Y8ci5sZW5ndGg7ZisrKWZvcihsZXQgcD0wO3A8VTtwKyspdT09Im5vbmUiP2lbZl1bcF09cltmXVtwXToodGhpcy5maWx0ZXJzW2ZdLnVwZGF0ZShyW2ZdW3BdLGMsLjEpLHU9PT0ibG9wYXNzIj9pW2ZdW3BdPXRoaXMuZmlsdGVyc1tmXS5zMTp1PT09ImhpcGFzcyI/aVtmXVtwXT1yW2ZdW3BdLXRoaXMuZmlsdGVyc1tmXS5zMTppW2ZdW3BdPXJbZl1bcF0pO3JldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigiZGpmLXByb2Nlc3NvciIsdGUpO2Z1bmN0aW9uIHoobil7Y29uc3QgdD1uKm47cmV0dXJuIG4qKDI3K3QpLygyNys5KnQpfWNvbnN0IGR0PTMuMTQxNTkyNjUzNTk7Y2xhc3MgZWUgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6NTAwfSx7bmFtZToicSIsZGVmYXVsdFZhbHVlOjF9LHtuYW1lOiJkcml2ZSIsZGVmYXVsdFZhbHVlOi42OX1dfWNvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnN0YXJ0ZWQ9ITEsdGhpcy5wMD1bMCwwXSx0aGlzLnAxPVswLDBdLHRoaXMucDI9WzAsMF0sdGhpcy5wMz1bMCwwXSx0aGlzLnAzMj1bMCwwXSx0aGlzLnAzMz1bMCwwXSx0aGlzLnAzND1bMCwwXX1wcm9jZXNzKHQsZSxzKXtjb25zdCByPXRbMF0saT1lWzBdLG89clswXSE9PXZvaWQgMDtpZih0aGlzLnN0YXJ0ZWQmJiFvKXJldHVybiExO3RoaXMuc3RhcnRlZD1vO2NvbnN0IGE9cy5xWzBdLHU9TShNYXRoLmV4cChzLmRyaXZlWzBdKSwuMSwyZTMpO2xldCBjPXMuZnJlcXVlbmN5WzBdO2M9YyoyKmR0L3NhbXBsZVJhdGUsYz1jPjE/MTpjO2NvbnN0IGg9TWF0aC5taW4oOCxhKi4xMyk7bGV0IGY9MS91Kk1hdGgubWluKDEuNzUsMStoKTtmb3IobGV0IHA9MDtwPFU7cCsrKWZvcihsZXQgbD0wO2w8ci5sZW5ndGg7bCsrKXtjb25zdCBtPXRoaXMucDNbbF0qLjM2MDg5MSt0aGlzLnAzMltsXSouNDE3MjkrdGhpcy5wMzNbbF0qLjE3Nzg5Nit0aGlzLnAzNFtsXSouMDQzOTcyNTt0aGlzLnAzNFtsXT10aGlzLnAzM1tsXSx0aGlzLnAzM1tsXT10aGlzLnAzMltsXSx0aGlzLnAzMltsXT10aGlzLnAzW2xdLHRoaXMucDBbbF0rPSh6KHJbbF1bcF0qdS1oKm0pLXoodGhpcy5wMFtsXSkpKmMsdGhpcy5wMVtsXSs9KHoodGhpcy5wMFtsXSkteih0aGlzLnAxW2xdKSkqYyx0aGlzLnAyW2xdKz0oeih0aGlzLnAxW2xdKS16KHRoaXMucDJbbF0pKSpjLHRoaXMucDNbbF0rPSh6KHRoaXMucDJbbF0pLXoodGhpcy5wM1tsXSkpKmMsaVtsXVtwXT1tKmZ9cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJsYWRkZXItcHJvY2Vzc29yIixlZSk7Y2xhc3Mgc2UgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiZGlzdG9ydCIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJwb3N0Z2FpbiIsZGVmYXVsdFZhbHVlOjF9XX1jb25zdHJ1Y3Rvcih7cHJvY2Vzc29yT3B0aW9uczp0fSl7c3VwZXIoKSx0aGlzLnN0YXJ0ZWQ9ITEsdGhpcy5hbGdvcml0aG09S3QodC5hbGdvcml0aG0pfXByb2Nlc3ModCxlLHMpe2NvbnN0IHI9dFswXSxpPWVbMF0sbz1yWzBdIT09dm9pZCAwO2lmKHRoaXMuc3RhcnRlZCYmIW8pcmV0dXJuITE7dGhpcy5zdGFydGVkPW87Zm9yKGxldCBhPTA7YTxVO2ErKyl7Y29uc3QgdT1NKFMocy5wb3N0Z2FpbixhKSwuMDAxLDEpLGM9TWF0aC5leHBtMShTKHMuZGlzdG9ydCxhKSk7Zm9yKGxldCBoPTA7aDxyLmxlbmd0aDtoKyspe2NvbnN0IGY9cltoXVthXTtpW2hdW2FdPXUqdGhpcy5hbGdvcml0aG0oZixjKX19cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJkaXN0b3J0LXByb2Nlc3NvciIsc2UpO2NsYXNzIHJlIGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBoYXNlPVtdfXN0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImJlZ2luIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6NDQwLG1pbjpOdW1iZXIuRVBTSUxPTn0se25hbWU6InBhbnNwcmVhZCIsZGVmYXVsdFZhbHVlOi40LG1pbjowLG1heDoxfSx7bmFtZToiZnJlcXNwcmVhZCIsZGVmYXVsdFZhbHVlOi4yLG1pbjowfSx7bmFtZToiZGV0dW5lIixkZWZhdWx0VmFsdWU6MCxtaW46MH0se25hbWU6InZvaWNlcyIsZGVmYXVsdFZhbHVlOjUsbWluOjF9XX1wcm9jZXNzKHQsZSxzKXtpZihjdXJyZW50VGltZTw9cy5iZWdpblswXSlyZXR1cm4hMDtpZihjdXJyZW50VGltZT49cy5lbmRbMF0pcmV0dXJuITE7Y29uc3Qgcj1lWzBdO2ZvcihsZXQgaT0wO2k8clswXS5sZW5ndGg7aSsrKXtjb25zdCBvPVMocy5kZXR1bmUsaSksYT1TKHMudm9pY2VzLGkpLHU9UyhzLmZyZXFzcHJlYWQsaSksYz1TKHMucGFuc3ByZWFkLGkpKi41Ky41LGg9TWF0aC5zcXJ0KDEtYyksZj1NYXRoLnNxcnQoYyk7bGV0IHA9UyhzLmZyZXF1ZW5jeSxpKTtwPUgocCxvLzEwMCk7Zm9yKGxldCBsPTA7bDxhO2wrKyl7Y29uc3QgbT0obCYxKT09MTtsZXQgZD1oLGI9ZjttJiYoZD1mLGI9aCk7Y29uc3QgST1IKHAsTnQoYSx1LGwpKSx2PXh0KEkvc2FtcGxlUmF0ZSwxKTt0aGlzLnBoYXNlW2xdPXRoaXMucGhhc2VbbF0/P01hdGgucmFuZG9tKCk7Y29uc3QgUD1wdC5zYXdibGVwKHRoaXMucGhhc2VbbF0sdik7clswXVtpXT1yWzBdW2ldK1AqZCxyWzFdW2ldPXJbMV1baV0rUCpiLHRoaXMucGhhc2VbbF09RnQodGhpcy5waGFzZVtsXSt2KX19cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJzdXBlcnNhdy1vc2NpbGxhdG9yIixyZSk7Y29uc3QgbmU9MjA0ODtmdW5jdGlvbiBpZShuKXtsZXQgdD1uZXcgRmxvYXQzMkFycmF5KG4pO2Zvcih2YXIgZT0wO2U8bjtlKyspdFtlXT0uNSooMS1NYXRoLmNvcygyKk1hdGguUEkqZS9uKSk7cmV0dXJuIHR9Y2xhc3Mgb2UgZXh0ZW5kcyBMe3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6InBpdGNoRmFjdG9yIixkZWZhdWx0VmFsdWU6MX1dfWNvbnN0cnVjdG9yKHQpe3QucHJvY2Vzc29yT3B0aW9ucz17YmxvY2tTaXplOm5lfSxzdXBlcih0KSx0aGlzLmZmdFNpemU9dGhpcy5ibG9ja1NpemUsdGhpcy50aW1lQ3Vyc29yPTAsdGhpcy5oYW5uV2luZG93PWllKHRoaXMuYmxvY2tTaXplKSx0aGlzLmZmdD1uZXcga3QodGhpcy5mZnRTaXplKSx0aGlzLmZyZXFDb21wbGV4QnVmZmVyPXRoaXMuZmZ0LmNyZWF0ZUNvbXBsZXhBcnJheSgpLHRoaXMuZnJlcUNvbXBsZXhCdWZmZXJTaGlmdGVkPXRoaXMuZmZ0LmNyZWF0ZUNvbXBsZXhBcnJheSgpLHRoaXMudGltZUNvbXBsZXhCdWZmZXI9dGhpcy5mZnQuY3JlYXRlQ29tcGxleEFycmF5KCksdGhpcy5tYWduaXR1ZGVzPW5ldyBGbG9hdDMyQXJyYXkodGhpcy5mZnRTaXplLzIrMSksdGhpcy5wZWFrSW5kZXhlcz1uZXcgSW50MzJBcnJheSh0aGlzLm1hZ25pdHVkZXMubGVuZ3RoKSx0aGlzLm5iUGVha3M9MH1wcm9jZXNzT0xBKHQsZSxzKXtsZXQgcj1zLnBpdGNoRmFjdG9yW3MucGl0Y2hGYWN0b3IubGVuZ3RoLTFdO3I8MCYmKHI9ciouMjUpLHI9TWF0aC5tYXgoMCxyKzEpO2Zvcih2YXIgaT0wO2k8dGhpcy5uYklucHV0cztpKyspZm9yKHZhciBvPTA7bzx0W2ldLmxlbmd0aDtvKyspe3ZhciBhPXRbaV1bb10sdT1lW2ldW29dO3RoaXMuYXBwbHlIYW5uV2luZG93KGEpLHRoaXMuZmZ0LnJlYWxUcmFuc2Zvcm0odGhpcy5mcmVxQ29tcGxleEJ1ZmZlcixhKSx0aGlzLmNvbXB1dGVNYWduaXR1ZGVzKCksdGhpcy5maW5kUGVha3MoKSx0aGlzLnNoaWZ0UGVha3MociksdGhpcy5mZnQuY29tcGxldGVTcGVjdHJ1bSh0aGlzLmZyZXFDb21wbGV4QnVmZmVyU2hpZnRlZCksdGhpcy5mZnQuaW52ZXJzZVRyYW5zZm9ybSh0aGlzLnRpbWVDb21wbGV4QnVmZmVyLHRoaXMuZnJlcUNvbXBsZXhCdWZmZXJTaGlmdGVkKSx0aGlzLmZmdC5mcm9tQ29tcGxleEFycmF5KHRoaXMudGltZUNvbXBsZXhCdWZmZXIsdSksdGhpcy5hcHBseUhhbm5XaW5kb3codSl9dGhpcy50aW1lQ3Vyc29yKz10aGlzLmhvcFNpemV9YXBwbHlIYW5uV2luZG93KHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5ibG9ja1NpemU7ZSsrKXRbZV09dFtlXSp0aGlzLmhhbm5XaW5kb3dbZV0qMS42Mn1jb21wdXRlTWFnbml0dWRlcygpe2Zvcih2YXIgdD0wLGU9MDt0PHRoaXMubWFnbml0dWRlcy5sZW5ndGg7KXtsZXQgcz10aGlzLmZyZXFDb21wbGV4QnVmZmVyW2VdLHI9dGhpcy5mcmVxQ29tcGxleEJ1ZmZlcltlKzFdO3RoaXMubWFnbml0dWRlc1t0XT1zKioyK3IqKjIsdCs9MSxlKz0yfX1maW5kUGVha3MoKXt0aGlzLm5iUGVha3M9MDt2YXIgdD0yO2xldCBlPXRoaXMubWFnbml0dWRlcy5sZW5ndGgtMjtmb3IoO3Q8ZTspe2xldCBzPXRoaXMubWFnbml0dWRlc1t0XTtpZih0aGlzLm1hZ25pdHVkZXNbdC0xXT49c3x8dGhpcy5tYWduaXR1ZGVzW3QtMl0+PXMpe3QrKztjb250aW51ZX1pZih0aGlzLm1hZ25pdHVkZXNbdCsxXT49c3x8dGhpcy5tYWduaXR1ZGVzW3QrMl0+PXMpe3QrKztjb250aW51ZX10aGlzLnBlYWtJbmRleGVzW3RoaXMubmJQZWFrc109dCx0aGlzLm5iUGVha3MrKyx0Kz0yfX1zaGlmdFBlYWtzKHQpe3RoaXMuZnJlcUNvbXBsZXhCdWZmZXJTaGlmdGVkLmZpbGwoMCk7Zm9yKHZhciBlPTA7ZTx0aGlzLm5iUGVha3M7ZSsrKXtsZXQgbz10aGlzLnBlYWtJbmRleGVzW2VdLGE9TWF0aC5yb3VuZChvKnQpO2lmKGE+dGhpcy5tYWduaXR1ZGVzLmxlbmd0aClicmVhazt2YXIgcz0wLHI9dGhpcy5mZnRTaXplO2lmKGU+MCl7bGV0IGg9dGhpcy5wZWFrSW5kZXhlc1tlLTFdO3M9by1NYXRoLmZsb29yKChvLWgpLzIpfWlmKGU8dGhpcy5uYlBlYWtzLTEpe2xldCBoPXRoaXMucGVha0luZGV4ZXNbZSsxXTtyPW8rTWF0aC5jZWlsKChoLW8pLzIpfWxldCB1PXMtbyxjPXItbztmb3IodmFyIGk9dTtpPGM7aSsrKXtsZXQgaD1vK2ksZj1hK2k7aWYoZj49dGhpcy5tYWduaXR1ZGVzLmxlbmd0aClicmVhaztsZXQgcD0yKk1hdGguUEkqKGYtaCkvdGhpcy5mZnRTaXplLGw9TWF0aC5jb3MocCp0aGlzLnRpbWVDdXJzb3IpLG09TWF0aC5zaW4ocCp0aGlzLnRpbWVDdXJzb3IpLGQ9aCoyLGI9ZCsxLEk9dGhpcy5mcmVxQ29tcGxleEJ1ZmZlcltkXSx2PXRoaXMuZnJlcUNvbXBsZXhCdWZmZXJbYl0sUD1JKmwtdiptLHc9SSptK3YqbCxUPWYqMixCPVQrMTt0aGlzLmZyZXFDb21wbGV4QnVmZmVyU2hpZnRlZFtUXSs9UCx0aGlzLmZyZXFDb21wbGV4QnVmZmVyU2hpZnRlZFtCXSs9d319fX1yZWdpc3RlclByb2Nlc3NvcigicGhhc2Utdm9jb2Rlci1wcm9jZXNzb3IiLG9lKTtjbGFzcyBhZSBleHRlbmRzIEF1ZGlvV29ya2xldFByb2Nlc3Nvcntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5waT1kdCx0aGlzLnBoaT0tdGhpcy5waSx0aGlzLlkwPTAsdGhpcy5ZMT0wLHRoaXMuUFc9dGhpcy5waSx0aGlzLkI9Mi4zLHRoaXMuZHBoaWY9MCx0aGlzLmVudmY9MH1zdGF0aWMgZ2V0IHBhcmFtZXRlckRlc2NyaXB0b3JzKCl7cmV0dXJuW3tuYW1lOiJiZWdpbiIsZGVmYXVsdFZhbHVlOjAsbWF4Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWSxtaW46MH0se25hbWU6ImVuZCIsZGVmYXVsdFZhbHVlOjAsbWF4Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWSxtaW46MH0se25hbWU6ImZyZXF1ZW5jeSIsZGVmYXVsdFZhbHVlOjQ0MCxtaW46TnVtYmVyLkVQU0lMT059LHtuYW1lOiJkZXR1bmUiLGRlZmF1bHRWYWx1ZTowLG1pbjpOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksbWF4Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWX0se25hbWU6InB1bHNld2lkdGgiLGRlZmF1bHRWYWx1ZToxLG1pbjowLG1heDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl9XX1wcm9jZXNzKHQsZSxzKXtpZih0aGlzLmRpc2Nvbm5lY3RlZClyZXR1cm4hMTtpZihjdXJyZW50VGltZTw9cy5iZWdpblswXSlyZXR1cm4hMDtpZihjdXJyZW50VGltZT49cy5lbmRbMF0pcmV0dXJuITE7Y29uc3Qgcj1lWzBdO2xldCBpPTEsbztmb3IobGV0IGE9MDthPChyWzBdLmxlbmd0aD8/MCk7YSsrKXtjb25zdCB1PSgxLU0oUShhLHMucHVsc2V3aWR0aCksLS45OSwuOTkpKSp0aGlzLnBpLGM9UShhLHMuZGV0dW5lKSxoPUgoUShhLHMuZnJlcXVlbmN5KSxjLzEwMCk7bz1oKih0aGlzLnBpLyhzYW1wbGVSYXRlKi41KSksdGhpcy5kcGhpZis9LjEqKG8tdGhpcy5kcGhpZiksaSo9Ljk5OTgsdGhpcy5lbnZmKz0uMSooaS10aGlzLmVudmYpLHRoaXMuQj0yLjMqKDEtMWUtNCpoKSx0aGlzLkI8MCYmKHRoaXMuQj0wKSx0aGlzLnBoaSs9dGhpcy5kcGhpZix0aGlzLnBoaT49dGhpcy5waSYmKHRoaXMucGhpLT0yKnRoaXMucGkpO2xldCBmPU1hdGguY29zKHRoaXMucGhpK3RoaXMuQip0aGlzLlkwKTt0aGlzLlkwPS41KihmK3RoaXMuWTApO2xldCBwPU1hdGguY29zKHRoaXMucGhpK3RoaXMuQip0aGlzLlkxK3UpO3RoaXMuWTE9LjUqKHArdGhpcy5ZMSk7Zm9yKGxldCBsPTA7bDxyLmxlbmd0aDtsKyspcltsXVthXT0uMTUqKGYtcCkqdGhpcy5lbnZmfXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigicHVsc2Utb3NjaWxsYXRvciIsYWUpO2NvbnN0IG10PXtiaXRDOmZ1bmN0aW9uKG4sdCxlKXtyZXR1cm4gbiZ0P2U6MH0sYnI6ZnVuY3Rpb24obix0PTgpe2lmKHQ+MzIpdGhyb3cgbmV3IEVycm9yKCJicigpIFNpemUgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAzMiIpO3tsZXQgZT0wO2ZvcihsZXQgcz0wO3M8dC0wO3MrKyllKz1tdC5iaXRDKG4sMioqcywyKioodC0ocysxKSkpO3JldHVybiBlfX0sc2luZjpmdW5jdGlvbihuKXtyZXR1cm4gTWF0aC5zaW4obi8oMTI4L01hdGguUEkpKX0sY29zZjpmdW5jdGlvbihuKXtyZXR1cm4gTWF0aC5jb3Mobi8oMTI4L01hdGguUEkpKX0sdGFuZjpmdW5jdGlvbihuKXtyZXR1cm4gTWF0aC50YW4obi8oMTI4L01hdGguUEkpKX0scmVnRzpmdW5jdGlvbihuLHQpe3JldHVybiB0LnRlc3Qobi50b1N0cmluZygyKSl9fTtsZXQgSixodDtmdW5jdGlvbiBjZShuKXtpZigoSnx8aHQpPT1udWxsKXtKPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE1hdGgpLGh0PUoubWFwKHM9Pk1hdGhbc10pO2NvbnN0IHQ9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobXQpLGU9dC5tYXAocz0+bXRbc10pO0oucHVzaCgiaW50Iiwid2luZG93IiwuLi50KSxodC5wdXNoKE1hdGguZmxvb3IsZ2xvYmFsVGhpcywuLi5lKX1yZXR1cm4gbmV3IEZ1bmN0aW9uKC4uLkosInQiLGByZXR1cm4gMCwKJHtufHwwfTtgKS5iaW5kKGdsb2JhbFRoaXMsLi4uaHQpfWNsYXNzIHVlIGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBvcnQub25tZXNzYWdlPXQ9PntsZXR7Y29kZVRleHQ6ZX09dC5kYXRhO2NvbnN0e2J5dGVCZWF0U3RhcnRUaW1lOnN9PXQuZGF0YTtzIT1udWxsJiYodGhpcy50PTAsdGhpcy5pbml0aWFsT2Zmc2V0PU1hdGguZmxvb3IocykpLGU9ZS50cmltKCkucmVwbGFjZSgvXmV2YWxcKHVuZXNjYXBlXChlc2NhcGUoPzpgfFwoJ3xcKCJ8XChgKSguKj8pKD86YHwnXCl8IlwpfGBcKSkucmVwbGFjZVwoXC91XChcLlwuXClcL2csWyInYF1cJDElWyInYF1cKVwpXCkkLywocixpKT0+dW5lc2NhcGUoZXNjYXBlKGkpLnJlcGxhY2UoL3UoLi4pL2csIiQxJSIpKSksdGhpcy5mdW5jPWNlKGUpfSx0aGlzLmluaXRpYWxPZmZzZXQ9bnVsbCx0aGlzLnQ9bnVsbCx0aGlzLmZ1bmM9bnVsbH1zdGF0aWMgZ2V0IHBhcmFtZXRlckRlc2NyaXB0b3JzKCl7cmV0dXJuW3tuYW1lOiJiZWdpbiIsZGVmYXVsdFZhbHVlOjAsbWF4Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWSxtaW46MH0se25hbWU6ImZyZXF1ZW5jeSIsZGVmYXVsdFZhbHVlOjQ0MCxtaW46TnVtYmVyLkVQU0lMT059LHtuYW1lOiJkZXR1bmUiLGRlZmF1bHRWYWx1ZTowLG1pbjpOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksbWF4Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWX0se25hbWU6ImVuZCIsZGVmYXVsdFZhbHVlOjAsbWF4Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWSxtaW46MH1dfXByb2Nlc3ModCxlLHMpe2lmKHRoaXMuZGlzY29ubmVjdGVkKXJldHVybiExO2lmKGN1cnJlbnRUaW1lPD1zLmJlZ2luWzBdKXJldHVybiEwO2lmKGN1cnJlbnRUaW1lPj1zLmVuZFswXSlyZXR1cm4hMTt0aGlzLnQ9PW51bGwmJih0aGlzLnQ9cy5iZWdpblswXSpzYW1wbGVSYXRlKTtjb25zdCByPWVbMF07Zm9yKGxldCBpPTA7aTxyWzBdLmxlbmd0aDtpKyspe2NvbnN0IG89UShpLHMuZGV0dW5lKSxhPUgoUShpLHMuZnJlcXVlbmN5KSxvLzEwMCk7bGV0IHU9dGhpcy50LyhzYW1wbGVSYXRlLzI1NikqYSt0aGlzLmluaXRpYWxPZmZzZXQ7Y29uc3QgZj0oKHRoaXMuZnVuYyh1KSYyNTUpLzEyNy41LTEpKi4yO2ZvcihsZXQgcD0wO3A8ci5sZW5ndGg7cCsrKXJbcF1baV09TShmLC0uNCwuNCk7dGhpcy50PXRoaXMudCsxfXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigiYnl0ZS1iZWF0LXByb2Nlc3NvciIsdWUpO2NvbnN0IGc9T2JqZWN0LmZyZWV6ZSh7Tk9ORTowLEFTWU06MSxNSVJST1I6MixCRU5EUDozLEJFTkRNOjQsQkVORE1QOjUsU1lOQzo2LFFVQU5UOjcsRk9MRDo4LFBXTTo5LE9SQklUOjEwLFNQSU46MTEsQ0hBT1M6MTIsUFJJTUVTOjEzLEJJTkFSWToxNCxCUk9XTklBTjoxNSxSRUNJUFJPQ0FMOjE2LFdPUk1IT0xFOjE3LExPR0lTVElDOjE4LFNJR01PSUQ6MTksRlJBQ1RBTDoyMCxGTElQOjIxfSk7ZnVuY3Rpb24gaGUobil7cmV0dXJuIG49bisyMTI3OTEyMjE0KyhuPDwxMiksbj1uXjMzNDUwNzI3MDBebj4+PjE5LG49biszNzQ3NjEzOTMrKG48PDUpLG49biszNTUwNjM1MTE2Xm48PDksbj1uKzQyNTE5OTM3OTcrKG48PDMpLG49bl4zMDQyNTk0NTY5Xm4+Pj4xNixuPj4+MH1jb25zdCBSdD1uPT4oaGUobik+Pj44KS8xNjc3NzIxNjtmdW5jdGlvbiBsZShuLHQpe2xldCBlPTA7Zm9yKGxldCBzPTA7czx0O3MrKyllPWU8PDF8biYxLG4+Pj49MTtyZXR1cm4gZX1mdW5jdGlvbiBmZShuKXtjb25zdCB0PU1hdGguZmxvb3IobiksZT1uLXQscz1SdCh0KSxyPVJ0KHQrMSk7cmV0dXJuIHMrKHItcykqZX1mdW5jdGlvbiBwZShuLHQ9NCl7bGV0IGU9LjUscz0wLHI9MCxpPTE7Zm9yKGxldCBvPTA7bzx0O28rKylzKz1lKmZlKG4qaSkscis9ZSxlKj0uNSxpKj0yO3JldHVybiBzL3IqMi0xfWNvbnN0IHZ0PXt9O2NsYXNzIGRlIGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImJlZ2luIixkZWZhdWx0VmFsdWU6MCxtaW46MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MCxtaW46MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfSx7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6NDQwLG1pbjpOdW1iZXIuRVBTSUxPTn0se25hbWU6ImRldHVuZSIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJmcmVxc3ByZWFkIixkZWZhdWx0VmFsdWU6LjE4LG1pbjowfSx7bmFtZToicG9zaXRpb24iLGRlZmF1bHRWYWx1ZTowLG1pbjowLG1heDoxfSx7bmFtZToid2FycCIsZGVmYXVsdFZhbHVlOjAsbWluOjAsbWF4OjF9LHtuYW1lOiJ3YXJwTW9kZSIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJ2b2ljZXMiLGRlZmF1bHRWYWx1ZToxLG1pbjoxfSx7bmFtZToicGFuc3ByZWFkIixkZWZhdWx0VmFsdWU6LjcsbWluOjAsbWF4OjF9LHtuYW1lOiJwaGFzZXJhbmQiLGRlZmF1bHRWYWx1ZTowLG1pbjowLG1heDoxfV19Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpcy5mcmFtZUxlbj0wLHRoaXMubnVtRnJhbWVzPTAsdGhpcy5waGFzZT1bXSx0aGlzLmludlNSPTEvc2FtcGxlUmF0ZSx0aGlzLnBvcnQub25tZXNzYWdlPWU9Pntjb25zdHt0eXBlOnMscGF5bG9hZDpyfT1lLmRhdGF8fHt9O2lmKHM9PT0idGFibGUiKXtjb25zdCBpPXIua2V5O2lmKHRoaXMuZnJhbWVMZW49ci5mcmFtZUxlbiwhdnRbaV0pe2NvbnN0IG89W3IuZnJhbWVzXTtsZXQgYT1vWzBdO2ZvcihsZXQgdT0xO3U8MTt1Kyspe2NvbnN0IGM9YS5sZW5ndGg+PjEsaD1hLm1hcChmPT57Y29uc3QgcD1uZXcgRmxvYXQzMkFycmF5KGMpO2ZvcihsZXQgbD0wO2w8YztsKyspcFtsXT0oZlsyKmxdK2ZbMipsKzFdKS8yO3JldHVybiBwfSk7aWYoby5wdXNoKGgpLGE9aCxjPD0zMilicmVha312dFtpXT1vfXRoaXMudGFibGVzPXZ0W2ldLHRoaXMubnVtRnJhbWVzPXRoaXMudGFibGVzWzBdLmxlbmd0aH19fV9taXJyb3IodCl7cmV0dXJuIDEtTWF0aC5hYnMoMip0LTEpfV90b0JpdHModCxlPTIscz0xMil7Y29uc3Qgcj1zKyhlLXMpKnQ7cmV0dXJue2I6cixuOk1hdGgucm91bmQoTWF0aC5wb3coMixyKSl9fV93YXJwUGhhc2UodCxlLHMpe3N3aXRjaChzKXtjYXNlIGcuTk9ORTpyZXR1cm4gdDtjYXNlIGcuQVNZTTp7Y29uc3Qgcj0uMDErLjk5KmU7cmV0dXJuIHQ8cj8uNSp0L3I6LjUrLjUqKHQtcikvKDEtcil9Y2FzZSBnLk1JUlJPUjpyZXR1cm4gdGhpcy5fbWlycm9yKHRoaXMuX3dhcnBQaGFzZSh0LGUsZy5BU1lNKSk7Y2FzZSBnLkJFTkRQOnJldHVybiBNYXRoLnBvdyh0LDErMyplKTtjYXNlIGcuQkVORE06cmV0dXJuIE1hdGgucG93KHQsMS8oMSszKmUpKTtjYXNlIGcuQkVORE1QOnJldHVybiBlPC41P3RoaXMuX3dhcnBQaGFzZSh0LDEtMiplLDMpOnRoaXMuX3dhcnBQaGFzZSh0LDIqZS0xLDIpO2Nhc2UgZy5TWU5DOntjb25zdCByPU1hdGgucG93KDE2LGUqZSk7cmV0dXJuIHQqciUxfWNhc2UgZy5RVUFOVDp7Y29uc3R7bjpyfT10aGlzLl90b0JpdHMoZSk7cmV0dXJuIGZ0KHQqcikvcn1jYXNlIGcuRk9MRDp7Y29uc3QgaT0xK01hdGgubWF4KDEsTWF0aC5yb3VuZCg3KmUpKTtyZXR1cm4gTWF0aC5hYnMoVyhpKnQpLS41KSoyfWNhc2UgZy5QV006e2NvbnN0IHI9TSguNSsuNDkqKDIqZS0xKSwwLDEpO3JldHVybiB0PHI/dC9yKi41Oi41Kyh0LXIpLygxLXIpKi41fWNhc2UgZy5PUkJJVDp7Y29uc3Qgcj0uNSplO3JldHVybiBXKHQrcipNYXRoLnNpbigyKk1hdGguUEkqMyp0KSl9Y2FzZSBnLlNQSU46e2NvbnN0IHI9LjUqZSx7bjppfT10aGlzLl90b0JpdHMoZSwxLDYpO3JldHVybiBXKHQrcipNYXRoLnNpbigyKk1hdGguUEkqaSp0KSl9Y2FzZSBnLkNIQU9TOntjb25zdCBpPSgzLjcrLjMqZSkqdCooMS10KTtyZXR1cm4gTSgoMS1lKSp0K2UqaSwwLDEpfWNhc2UgZy5QUklNRVM6e2NvbnN0IHI9bz0+e2lmKG88MilyZXR1cm4hMTtpZihvJTI9PT0wKXJldHVybiBvPT09Mjtmb3IobGV0IGE9MzthKmE8PW87YSs9MilpZihvJWE9PT0wKXJldHVybiExO3JldHVybiEwfTtsZXR7bjppfT10aGlzLl90b0JpdHMoZSwzKTtmb3IoOyFyKGkpOylpKys7cmV0dXJuIGZ0KHQqaSkvaX1jYXNlIGcuQklOQVJZOntsZXR7YjpyfT10aGlzLl90b0JpdHMoZSwzKTtyPU1hdGgucm91bmQocik7Y29uc3QgaT0xPDxyLG89ZnQodCppKTtyZXR1cm4gbGUobyxyKS9pfWNhc2UgZy5NT0RVTEFSOntjb25zdHtuOnJ9PXRoaXMuX3RvQml0cyhlKSxpPS41KmUsbz1XKHQqcikvcjtyZXR1cm4gVyh0K2kqbyl9Y2FzZSBnLkJST1dOSUFOOntjb25zdCByPS4yNSplKnBlKDY0KnQsNCk7cmV0dXJuIFcodCtyKX1jYXNlIGcuUkVDSVBST0NBTDp7Y29uc3Qgcj0yKzQqZSxpPXQqcixvPXQrKDEtdCkqcixhPW8+MWUtMTI/aS9vOjA7cmV0dXJuIE0oYSwwLDEpfWNhc2UgZy5XT1JNSE9MRTp7Y29uc3Qgcj1NKC44KmUsMCwxKSxpPS41KigxLXIpLG89LjUqKDErcik7cmV0dXJuIHQ8aT90L2kqLjU6dD5vPy41KigxKyh0LW8pLygxLW8pKTouNX1jYXNlIGcuTE9HSVNUSUM6e2xldCByPXQ7Y29uc3QgaT0zLjYrLjQqZSxvPTErTWF0aC5yb3VuZCgyKmUpO2ZvcihsZXQgYT0wO2E8bzthKyspcj1pKnIqKDEtcik7cmV0dXJuIE0ociwwLDEpfWNhc2UgZy5TSUdNT0lEOntjb25zdCByPTErMTAqZSxpPXQtLjUsbz0xLygxK01hdGguZXhwKC1yKmkpKSxhPTEvKDErTWF0aC5leHAoLjUqcikpLHU9MS8oMStNYXRoLmV4cCgtLjUqcikpO3JldHVybihvLWEpLyh1LWEpfWNhc2UgZy5GUkFDVEFMOntjb25zdCByPS41Kk1hdGguc2luKDIqTWF0aC5QSSp0KSplO3JldHVybiBXKHQrcil9Y2FzZSBnLkZMSVA6cmV0dXJuIHQ7ZGVmYXVsdDpyZXR1cm4gdH19X3NhbXBsZUZyYW1lKHQsZSl7Y29uc3Qgcz10Lmxlbmd0aCxyPWUqcztsZXQgaT1yfDA7aT49cyYmKGk9MCk7Y29uc3Qgbz1yLWksYT10W2ldO2xldCB1PWkrMTt1Pj1zJiYodT0wKTtjb25zdCBjPXRbdV07cmV0dXJuIGErKGMtYSkqb31fY2hvb3NlTWlwKHQpe3ZhciByO2NvbnN0IGU9TSh0LDFlLTYsNjQpO2xldCBzPTA7Zm9yKDtzKzE8KCgocj10aGlzLnRhYmxlcyk9PW51bGw/dm9pZCAwOnIubGVuZ3RoKXx8MSkmJmU8dGhpcy50YWJsZXNbc11bMF0ubGVuZ3RoLzg7KXMrKztyZXR1cm4gc31wcm9jZXNzKHQsZSxzKXtpZihjdXJyZW50VGltZT49cy5lbmRbMF0pcmV0dXJuITE7aWYoY3VycmVudFRpbWU8PXMuYmVnaW5bMF0pcmV0dXJuITA7Y29uc3Qgcj1lWzBdWzBdLGk9ZVswXVsxXXx8ZVswXVswXTtpZighdGhpcy50YWJsZXMpcmV0dXJuIHIuZmlsbCgwKSxpIT09ciYmaS5zZXQociksITA7Zm9yKGxldCBvPTA7bzxyLmxlbmd0aDtvKyspe2NvbnN0IGE9UyhzLmRldHVuZSxvKSx1PVMocy5mcmVxc3ByZWFkLG8pLGg9TShTKHMucG9zaXRpb24sbyksMCwxKSoodGhpcy5udW1GcmFtZXMtMSksZj1ofDAscD1oLWYsbD1NKFMocy53YXJwLG8pLDAsMSksbT1TKHMud2FycE1vZGUsbyksZD1TKHMudm9pY2VzLG8pLGI9TShTKHMucGhhc2VyYW5kLG8pLDAsMSksST1kPjE/TShTKHMucGFuc3ByZWFkLG8pLDAsMSk6MCx2PU1hdGguc3FydCguNS0uNSpJKSxQPU1hdGguc3FydCguNSsuNSpJKTtsZXQgdz1TKHMuZnJlcXVlbmN5LG8pO3c9SCh3LGEvMTAwKTtjb25zdCBUPTEvTWF0aC5zcXJ0KGQpO2ZvcihsZXQgQj0wO0I8ZDtCKyspe2NvbnN0IEE9KEImMSk9PTE7bGV0IHk9dixPPVA7QSYmKHk9UCxPPXYpO2NvbnN0IHg9SCh3LE50KGQsdSxCKSkqdGhpcy5pbnZTUixFPXRoaXMuX2Nob29zZU1pcCh4KSxOPXRoaXMudGFibGVzW0VdO3RoaXMucGhhc2VbQl09dGhpcy5waGFzZVtCXT8/TWF0aC5yYW5kb20oKSpiO2NvbnN0IEY9dGhpcy5fd2FycFBoYXNlKHRoaXMucGhhc2VbQl0sbCxtKSxWPXRoaXMuX3NhbXBsZUZyYW1lKE5bZl0sRiksaz10aGlzLl9zYW1wbGVGcmFtZShOW01hdGgubWluKHRoaXMubnVtRnJhbWVzLTEsZisxKV0sRik7bGV0IFI9Visoay1WKSpwO209PT1nLkZMSVAmJnRoaXMucGhhc2VbQl08bCYmKFI9LVIpLHJbb10rPVIqeSpULGlbb10rPVIqTypULHRoaXMucGhhc2VbQl09RnQodGhpcy5waGFzZVtCXSt4KX19cmV0dXJuITB9fXJldHVybiByZWdpc3RlclByb2Nlc3Nvcigid2F2ZXRhYmxlLW9zY2lsbGF0b3ItcHJvY2Vzc29yIixkZSksQy5XYXJwTW9kZT1nLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6Ik1vZHVsZSJ9KSxDfSh7fSk7Cg==";
let Lt;
const Rn = () => (Lt = new AudioContext(), Lt), x = () => Lt || Rn();
function Co() {
  return x().currentTime;
}
let Ct = {};
function Le(t, e) {
  const n = x();
  if (Ct[t])
    return Ct[t];
  const o = 2 * n.sampleRate, s = n.createBuffer(1, o, n.sampleRate), c = s.getChannelData(0);
  let a = 0, d, l, i, r, u, p, h;
  d = l = i = r = u = p = h = 0;
  for (let m = 0; m < o; m++)
    if (t === "white")
      c[m] = Math.random() * 2 - 1;
    else if (t === "brown") {
      let b = Math.random() * 2 - 1;
      c[m] = (a + 0.02 * b) / 1.02, a = c[m];
    } else if (t === "pink") {
      let b = Math.random() * 2 - 1;
      d = 0.99886 * d + b * 0.0555179, l = 0.99332 * l + b * 0.0750759, i = 0.969 * i + b * 0.153852, r = 0.8665 * r + b * 0.3104856, u = 0.55 * u + b * 0.5329522, p = -0.7616 * p - b * 0.016898, c[m] = d + l + i + r + u + p + h + b * 0.5362, c[m] *= 0.11, h = b * 0.115926;
    } else if (t === "crackle") {
      const b = e * 0.01;
      Math.random() < b ? c[m] = Math.random() * 2 - 1 : c[m] = 0;
    }
  return t !== "crackle" && (Ct[t] = s), s;
}
function Jt(t = "white", e, n = 0.02) {
  const s = x().createBufferSource();
  return s.buffer = Le(t, n), s.loop = !0, s.start(e), {
    node: s,
    stop: (c) => s.stop(c)
  };
}
function Sn(t, e, n) {
  const o = Jt("pink", n);
  return {
    node: Yn(t, o.node, e),
    stop: (c) => o?.stop(c)
  };
}
const Ke = ["pink", "white", "brown", "crackle"];
function C(t) {
  const e = x().createGain();
  return e.gain.value = t, e;
}
function Ut(t, e, n) {
  const o = C(n);
  return t.connect(o), o.connect(e), o;
}
const me = (t, e, n, o) => o - n === 0 ? 0 : (e - t) / (o - n);
function I(t, e, n, o) {
  const s = new AudioWorkletNode(t, e, o);
  return Object.entries(n).forEach(([c, a]) => {
    a !== void 0 && (s.parameters.get(c).value = a);
  }), s;
}
const k = (t, e, n, o, s, c, a, d, l, i = "exponential") => {
  e = O(e), n = O(n), o = O(o), s = O(s);
  const r = i === "exponential" ? "exponentialRampToValueAtTime" : "linearRampToValueAtTime";
  i === "exponential" && (c = c === 0 ? 1e-3 : c, a = a === 0 ? 1e-3 : a);
  const u = a - c, p = a, h = c + o * u, m = l - d, b = (X) => {
    let y;
    if (e > X) {
      let Z = me(c, p, 0, e);
      y = X * Z + (c > p ? c : 0);
    } else
      y = (X - e) * me(p, h, 0, n) + p;
    return i === "exponential" && (y = y || 1e-3), y;
  };
  t.setValueAtTime(c, d), e > m ? t[r](b(m), l) : e + n > m ? (t[r](b(e), d + e), t[r](b(m), l)) : (t[r](b(e), d + e), t[r](b(e + n), d + e + n), t.setValueAtTime(h, l)), t[r](c, l + s);
};
function Nn(t) {
  return typeof t == "number" ? t % 5 : { tri: 0, triangle: 0, sine: 1, ramp: 2, saw: 3, square: 4 }[t] ?? 0;
}
function Tt(t, e, n, o = {}) {
  const { shape: s = 0, ...c } = o, { dcoffset: a = -0.5, depth: d = 1 } = o, l = {
    frequency: 1,
    depth: d,
    skew: 0.5,
    phaseoffset: 0,
    time: e,
    begin: e,
    end: n,
    shape: Nn(s),
    dcoffset: a,
    min: a * d,
    max: a * d + d,
    curve: 1,
    ...c
  };
  return I(t, "lfo-processor", l);
}
function wn(t, e, n, o, s, c) {
  const a = {
    threshold: e ?? -3,
    ratio: n ?? 10,
    knee: o ?? 10,
    attack: s ?? 5e-3,
    release: c ?? 0.05
  };
  return new DynamicsCompressorNode(t, a);
}
const Q = (t, e = "linear", n) => {
  const [a, d, l, i] = t;
  if (a == null && d == null && l == null && i == null)
    return n ?? [1e-3, 1e-3, 1, 0.01];
  const r = l ?? (a != null && d == null || a == null && d == null ? 1 : 1e-3);
  return [Math.max(a ?? 0, 1e-3), Math.max(d ?? 0, 1e-3), Math.min(r, 1), Math.max(i ?? 0, 0.01)];
};
function be(t, e, n, o, s, c) {
  let { amount: a, offset: d, defaultAmount: l = 1, curve: i = "linear", values: r, holdEnd: u, defaultValues: p } = s;
  a == null && (a = r.some((M) => M != null) ? l : 0);
  const h = d ?? 0, m = a + h;
  if (Math.abs(m - h)) {
    const [G, M, L, z] = Q(r, i, p);
    k(e, G, M, L, z, h, m, n, u, i);
  }
  let X, { defaultDepth: y = 1, depth: Z, dcoffset: W, ...V } = c;
  return Z == null && (Z = Object.values(V).some((M) => M != null) ? y : 0), Z && (X = Tt(t, n, o, {
    depth: Z,
    dcoffset: W,
    ...V
  }), X.connect(e)), { lfo: X, disconnect: () => X?.disconnect() };
}
function Ht(t, e, n, o, s, c, a, d, l, i, r, u, p, h) {
  const m = "exponential", [b, X, y, Z] = Q([s, c, a, d], m, [5e-3, 0.14, 0, 0.1]);
  let W, V;
  if (p === "ladder" ? (W = I(t, "ladder-processor", { frequency: n, q: o, drive: h }), V = W.parameters.get("frequency")) : (W = t.createBiquadFilter(), W.type = e, W.Q.value = o, W.frequency.value = n, V = W.frequency), (s ?? c ?? a ?? d ?? l) !== void 0) {
    l = O(l, 1, !0), u = O(u, 0, !0);
    const M = Math.abs(l), L = M * u;
    let z = D(2 ** -L * n, 0, 2e4), S = D(2 ** (M - L) * n, 0, 2e4);
    return l < 0 && ([z, S] = [S, z]), k(V, b, X, y, Z, z, S, i, r, m), W;
  }
  return W;
}
let Ze = (t) => t < 0.5 ? 1 : 1 - (t - 0.5) / 0.5;
function Yn(t, e, n = 0) {
  const o = x();
  if (!n)
    return t;
  let s = o.createGain(), c = o.createGain();
  t.connect(s), e.connect(c), s.gain.value = Ze(n), c.gain.value = Ze(1 - n);
  let a = o.createGain();
  return s.connect(a), c.connect(a), a;
}
let Fn = ["linear", "exponential"];
function ht(t, e, n, o) {
  if ((e.pattack ?? e.pdecay ?? e.psustain ?? e.prelease ?? e.penv) === void 0)
    return;
  const c = O(e.penv, 1, !0), a = Fn[e.pcurve ?? 0];
  let [d, l, i, r] = Q(
    [e.pattack, e.pdecay, e.psustain, e.prelease],
    a,
    [0.2, 1e-3, 1, 1e-3]
  ), u = e.panchor ?? i;
  const p = c * 100, h = 0 - p * u, m = p - p * u;
  k(t, d, l, i, r, h, m, n, o, a);
}
function pt(t, e, n) {
  const { vibmod: o = 0.5, vib: s } = e;
  let c;
  if (s > 0) {
    c = x().createOscillator(), c.frequency.value = s;
    const a = x().createGain();
    return a.gain.value = o * 100, c.connect(a), a.connect(t), c.start(n), c;
  }
}
function rt(t, e, n, o) {
  const s = new ConstantSourceNode(t), c = C(0);
  return c.connect(t.destination), s.connect(c), s.onended = () => {
    try {
      c.disconnect();
    } catch {
    }
    try {
      s.disconnect();
    } catch {
    }
    e();
  }, s.start(n), s.stop(o), s;
}
const Cn = (t, e = 1, n = "sine") => {
  const o = x();
  let s;
  Ke.includes(n) ? (s = o.createBufferSource(), s.buffer = Le(n, 2), s.loop = !0) : (s = o.createOscillator(), s.type = n, s.frequency.value = t), s.start();
  const c = new GainNode(o, { gain: e });
  return s.connect(c), { node: c, stop: (a) => s.stop(a) };
}, Hn = (t, e, n, o = "sine") => {
  const c = t.value * e, a = c * n;
  return Cn(c, a, o);
};
function Kt(t, e, n) {
  const {
    fmh: o = 1,
    fmi: s,
    fmenv: c = "exp",
    fmattack: a,
    fmdecay: d,
    fmsustain: l,
    fmrelease: i,
    fmvelocity: r,
    fmwave: u = "sine",
    duration: p
  } = e;
  let h, m = () => {
  };
  if (s) {
    const X = x().createGain(), y = Hn(t, o, s, u);
    if (h = y.node, m = y.stop, ![a, d, l, i, r].some((Z) => Z !== void 0))
      h.connect(t);
    else {
      const [Z, W, V, G] = Q([a, d, l, i]), M = n + p;
      k(
        X.gain,
        Z,
        W,
        V,
        G,
        0,
        1,
        n,
        M,
        c === "exp" ? "exponential" : "linear"
      ), h.connect(X), X.connect(t);
    }
  }
  return { stop: m };
}
const ze = (t) => t / (1 + t), In = (t, e) => (t % e + e) % e, Pn = (t, e) => (1 + e) * t / (1 + e * Math.abs(t)), nt = (t, e) => Math.tanh(t * (1 + e)), kn = (t, e) => D((1 + e) * t, -1, 1), Te = (t, e) => {
  let n = (1 + 0.5 * e) * t;
  const o = In(n + 1, 4);
  return 1 - Math.abs(o - 2);
}, Qn = (t, e) => Math.sin(Math.PI / 2 * Te(t, e)), Jn = (t, e) => {
  const n = ze(Math.log1p(e)), o = (t - n / 3 * t * t * t) / (1 - n / 3);
  return nt(o, e);
}, Re = (t, e, n = !1) => {
  const o = 1 + 2 * e, c = 0.07 * ze(Math.log1p(e)), a = nt(t + c, 2 * e), d = nt(n ? c : -t + c, 2 * e), l = a - d, i = 1 / Math.cosh(o * c), r = i * i, u = Math.max(1e-8, (n ? 1 : 2) * o * r);
  return nt(l / u, e);
}, Un = (t, e) => Re(t, e, !0), vn = (t, e) => {
  const n = 10 * Math.log1p(e);
  let o = 1, s = t, c, a = 0;
  for (let d = 1; d < 64; d++) {
    if (d < 2) {
      a += d == 0 ? o : s;
      continue;
    }
    c = 2 * t * o - s, s = o, o = c, d % 2 === 0 && (a += Math.min(1.3 * n / d, 2) * c);
  }
  return nt(a, n / 20);
}, Se = {
  scurve: Pn,
  soft: nt,
  hard: kn,
  cubic: Jn,
  diode: Re,
  asym: Un,
  fold: Te,
  sinefold: Qn,
  chebyshev: vn
}, dt = Object.freeze(Object.keys(Se)), Ho = (t) => {
  let e = t;
  typeof t == "string" && (e = dt.indexOf(t), e === -1 && (N(`[superdough] Could not find waveshaping algorithm ${t}.
        Available options are ${dt.join(", ")}.
        Defaulting to ${dt[0]}.`), e = 0));
  const n = dt[e % dt.length];
  return Se[n];
}, Bn = (t, e, n) => I(x(), "distort-processor", { distort: t, postgain: e }, { processorOptions: { algorithm: n } }), et = (t, e = 36) => {
  let { note: n, freq: o } = t;
  return n = n || e, typeof n == "string" && (n = zt(n)), !o && typeof n == "number" && (o = Me(n)), Number(o);
}, it = (t) => {
  t != null && (t.disconnect(), t.parameters.get("end")?.setValueAtTime(0, 0));
}, Ot = {}, It = {}, Io = (t) => Ot[t];
function jn(t, e) {
  var n = 1024;
  if (t < n) return t + " B";
  var o = ["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], s = -1;
  do
    t /= n, ++s;
  while (t >= n);
  return t.toFixed(1) + " " + o[s];
}
function On(t, e) {
  const { speed: n = 1 } = t, { transpose: o, url: s, index: c, midi: a, label: d } = ge(t, e);
  let l = Math.abs(n) * Math.pow(2, o / 12);
  return { transpose: o, url: s, index: c, midi: a, label: d, playbackRate: l };
}
const En = async (t, e, n) => {
  let { url: o, label: s, playbackRate: c } = On(t, e);
  n && (o = await n(o));
  const a = x(), d = await Ne(o, a, s);
  return t.unit === "c" && (c = c * d.duration), { buffer: d, playbackRate: c };
}, Dn = async (t, e, n) => {
  let { buffer: o, playbackRate: s } = await En(t, e, n);
  t.speed < 0 && (o = An(o));
  const a = x().createBufferSource();
  a.buffer = o, a.playbackRate.value = s;
  const { loopBegin: d = 0, loopEnd: l = 1, begin: i = 0, end: r = 1 } = t, u = i * a.buffer.duration;
  t.loop && (a.loop = !0, a.loopStart = d * a.buffer.duration - u, a.loopEnd = l * a.buffer.duration - u);
  const h = a.buffer.duration / a.playbackRate.value, m = (r - i) * h;
  return { bufferSource: a, offset: u, bufferDuration: h, sliceDuration: m };
}, Ne = (t, e, n, o = 0) => {
  const s = n ? `sound "${n}:${o}"` : "sample";
  if (t = t.replace("#", "%23"), !It[t]) {
    N(`[sampler] load ${s}..`, "load-sample", { url: t });
    const c = Date.now();
    It[t] = fetch(t).then((a) => a.arrayBuffer()).then(async (a) => {
      const d = Date.now() - c, l = jn(a.byteLength);
      N(`[sampler] load ${s}... done! loaded ${l} in ${d}ms`, "loaded-sample", { url: t });
      const i = await e.decodeAudioData(a);
      return Ot[t] = i, i;
    });
  }
  return It[t];
};
function An(t) {
  const e = x(), n = e.createBuffer(t.numberOfChannels, t.length, e.sampleRate);
  for (let o = 0; o < t.numberOfChannels; o++)
    n.copyToChannel(t.getChannelData(o).slice().reverse(), o, o);
  return n;
}
const Po = (t) => Ot[t];
function we(t) {
  if (t.startsWith("bubo:")) {
    const [e, n] = t.split(":");
    t = `github:Bubobubobubobubo/dough-${n}`;
  }
  return t;
}
function Ye(t, e = "") {
  if (!t.startsWith("github:"))
    throw new Error('expected "github:" at the start of pseudoUrl');
  let n = t.slice(7);
  n = n.endsWith("/") ? n.slice(0, -1) : n;
  let o = n.split("/"), s = o[0], c = o.length >= 2 ? o[1] : "samples", a = o.length >= 3 ? o[2] : "main", d = o.slice(3);
  return d.push(e || ""), d = d.join("/"), `https://raw.githubusercontent.com/${s}/${c}/${a}/${d}`;
}
const qn = (t, e, n = t._base || "") => Object.entries(t).forEach(([o, s]) => {
  if (typeof s == "string" && (s = [s]), typeof s != "object")
    throw new Error("wrong sample map format for " + o);
  n = s._base || n, n = we(n), n.startsWith("github:") && (n = Ye(n, ""));
  const c = (a) => n + a;
  Array.isArray(s) ? s = s.map(c) : s = Object.fromEntries(
    Object.entries(s).map(([a, d]) => [a, (typeof d == "string" ? [d] : d).map(c)])
  ), e(o, s);
});
let Fe = {};
function ko(t, e) {
  Fe[t] = e;
}
function $n(t) {
  const e = Object.entries(Fe).find(([n]) => t.startsWith(n));
  if (e)
    return e[1];
}
async function _n(t) {
  const e = $n(t);
  if (e)
    return e(t);
  if (t = we(t), t.startsWith("github:") && (t = Ye(t, "strudel.json")), t.startsWith("local:") && (t = "http://localhost:5432"), t.startsWith("shabda:")) {
    let [s, c] = t.split("shabda:");
    t = `https://shabda.ndre.gr/${c}.json?strudel=1`;
  }
  if (t.startsWith("shabda/speech")) {
    let [s, c] = t.split("shabda/speech");
    c = c.startsWith("/") ? c.substring(1) : c;
    let [a, d] = c.split(":"), l = "f", i = "en-GB";
    a && ([i, l] = a.split("/")), t = `https://shabda.ndre.gr/speech/${d}.json?gender=${l}&language=${i}&strudel=1'`;
  }
  if (typeof fetch != "function")
    return;
  const n = t.split("/").slice(0, -1).join("/");
  if (typeof fetch > "u")
    return;
  const o = await fetch(t).then((s) => s.json()).catch((s) => {
    throw console.error(s), new Error(`error loading "${t}"`);
  });
  return [o, o._base || n];
}
const to = async (t, e = t._base || "", n = {}) => {
  if (typeof t == "string") {
    const [c, a] = await _n(t);
    return to(c, e || a, n);
  }
  const { prebake: o, tag: s } = n;
  qn(
    t,
    (c, a) => {
      oo(c, a, { baseUrl: e, prebake: o, tag: s });
    },
    e
  );
}, Xe = [];
async function eo(t, e, n, o, s) {
  let {
    s: c,
    nudge: a = 0,
    // TODO: is this in seconds?
    cut: d,
    loop: l,
    clip: i = void 0,
    // if set, samples will be cut off when the hap ends
    n: r = 0,
    speed: u = 1,
    // sample playback speed
    duration: p
  } = e;
  if (u === 0)
    return;
  const h = x();
  let [m, b, X, y] = Q([e.attack, e.decay, e.sustain, e.release]);
  const { bufferSource: Z, sliceDuration: W, offset: V } = await Dn(e, o, s);
  if (h.currentTime > t) {
    N(`[sampler] still loading sound "${c}:${r}"`, "highlight");
    return;
  }
  if (!Z) {
    N(`[sampler] could not load "${c}:${r}"`, "error");
    return;
  }
  let G = pt(Z.detune, e, t);
  const M = t + a;
  Z.start(M, V);
  const L = h.createGain(), z = Z.connect(L);
  i == null && l == null && e.release == null && (p = W);
  let S = t + p;
  k(z.gain, m, b, X, y, 0, 1, t, S, "linear"), ht(Z.detune, e, t, S);
  const R = h.createGain();
  z.connect(R), Z.onended = function() {
    Z.disconnect(), G?.stop(), z.disconnect(), R.disconnect(), n();
  };
  let J = S + y + 0.01;
  Z.stop(J);
  const w = { node: R, bufferSource: Z, stop: (P) => {
    Z.stop(P);
  } };
  if (d !== void 0) {
    const P = Xe[d];
    P && (P.node.gain.setValueAtTime(1, M), P.node.gain.linearRampToValueAtTime(0, M + 0.01)), Xe[d] = w;
  }
  return w;
}
function no(t, e, n) {
  j(t, (o, s, c) => eo(o, s, c, e), {
    type: "sample",
    samples: e,
    ...n
  });
}
function oo(t, e, n) {
  t.startsWith("wt_") ? Be(t, e, n) : no(t, e, n);
}
let tt = (t, e) => t !== void 0 && t !== e;
class co {
  reverbNode;
  delayNode;
  output;
  summingNode;
  djfNode;
  audioContext;
  constructor(e) {
    this.audioContext = e, this.output = new GainNode(e, { gain: 1, channelCount: 2, channelCountMode: "explicit" }), this.summingNode = new GainNode(e, { gain: 1, channelCount: 2, channelCountMode: "explicit" }), this.summingNode.connect(this.output);
  }
  disconnect() {
    this.output.disconnect(), this.summingNode.disconnect(), this.delayNode?.disconnect(), this.reverbNode?.disconnect();
  }
  getDjf(e, n = 0) {
    this.djfNode == null && (this.djfNode = I(this.audioContext, "djf-processor", { value: e }), this.summingNode.disconnect(), this.summingNode.connect(this.djfNode), this.djfNode.connect(this.output)), this.djfNode.parameters.get("value").setValueAtTime(e, n);
  }
  getDelay(e = 0, n = 0.5, o) {
    return n = D(n, 0, 0.98), this.delayNode == null && (this.delayNode = this.audioContext.createFeedbackDelay(1, e, n), this.delayNode.connect(this.summingNode), this.delayNode.start?.(o)), this.delayNode.delayTime.value !== e && this.delayNode.delayTime.setValueAtTime(e, o), this.delayNode.feedback.value !== n && this.delayNode.feedback.setValueAtTime(n, o), this.delayNode;
  }
  getReverb(e, n, o, s, c, a, d) {
    return this.reverbNode == null && (this.reverbNode = this.audioContext.createReverb(e, n, o, s, c, a, d), this.reverbNode.connect(this.summingNode)), (tt(e, this.reverbNode.duration) || tt(n, this.reverbNode.fade) || tt(o, this.reverbNode.lp) || tt(s, this.reverbNode.dim) || tt(a, this.reverbNode.irspeed) || tt(d, this.reverbNode.irbegin) || this.reverbNode.ir !== c) && this.reverbNode.generate(e, n, o, s, c, a, d), this.reverbNode;
  }
  sendReverb(e, n) {
    Ut(e, this.reverbNode, n);
  }
  sendDelay(e, n) {
    Ut(e, this.delayNode, n);
  }
  duck(e, n = 0, o = 0.1, s = 1) {
    const c = n, a = Math.max(o, 2e-3), d = this.output.gain;
    rt(
      this.audioContext,
      () => {
        const l = this.audioContext.currentTime, i = d.value;
        d.cancelScheduledValues(l), d.setValueAtTime(i, l);
        const r = Math.max(e, l), u = D(1 - Math.sqrt(s), 0.01, i);
        d.exponentialRampToValueAtTime(u, r + c), d.exponentialRampToValueAtTime(1, r + c + a);
      },
      0,
      e - 0.01
    );
  }
  connectToOutput(e) {
    e.connect(this.summingNode);
  }
}
class so {
  channelMerger;
  destinationGain;
  constructor(e) {
    this.audioContext = e, this.initializeAudio();
  }
  initializeAudio() {
    const e = this.audioContext, n = e.destination.maxChannelCount;
    this.audioContext.destination.channelCount = n, this.channelMerger = new ChannelMergerNode(e, { numberOfInputs: e.destination.channelCount }), this.destinationGain = new GainNode(e), this.channelMerger.connect(this.destinationGain), this.destinationGain.connect(e.destination);
  }
  reset() {
    this.disconnect(), this.initializeAudio();
  }
  disconnect() {
    this.channelMerger.disconnect(), this.destinationGain.disconnect(), this.destinationGain = null, this.channelMerger = null;
  }
  connectToDestination = (e, n = [0, 1]) => {
    const o = new StereoPannerNode(this.audioContext);
    e.connect(o);
    const s = new ChannelSplitterNode(this.audioContext, {
      numberOfOutputs: o.channelCount
    });
    o.connect(s), n.forEach((c, a) => {
      s.connect(this.channelMerger, a % o.channelCount, c % this.audioContext.destination.channelCount);
    });
  };
}
class ao {
  audioContext;
  output;
  nodes = {};
  constructor(e) {
    this.audioContext = e, this.output = new so(e);
  }
  reset() {
    Array.from(this.nodes).forEach((e) => {
      e.disconnect();
    }), this.nodes = {}, this.output.reset();
  }
  duck(e, n, o = 0, s = 0.1, c = 1) {
    const a = [e].flat(), d = [o].flat(), l = [s].flat(), i = [c].flat();
    a.forEach((r, u) => {
      const p = this.nodes[r];
      if (p == null) {
        fn(new Error(`duck target orbit ${r} does not exist`), "superdough");
        return;
      }
      const h = d[u] ?? d[0], m = Math.max(l[u] ?? l[0], 2e-3), b = i[u] ?? i[0];
      p.duck(n, h, m, b);
    });
  }
  getOrbit(e, n) {
    return this.nodes[e] == null && (this.nodes[e] = new co(this.audioContext), this.output.connectToDestination(this.nodes[e].output, n)), this.nodes[e];
  }
}
const Ce = 128, vt = "System Standard";
let He = Ce;
function lo(t) {
  He = parseInt(t) ?? Ce;
}
let Ie = !1;
function io(t) {
  Ie = t == !0;
}
const B = yn();
function j(t, e, n = {}) {
  t = t.toLowerCase().replace(/\s+/g, "_"), B.setKey(t, { onTrigger: e, data: n });
}
let Pe = (t) => t;
function E(t) {
  return Pe(t);
}
function Qo(t) {
  Pe = t;
}
function Bt(t) {
  for (const n in t)
    t[n.toLowerCase()] = t[n];
  const e = B.get();
  for (const n in e) {
    const [o, s] = n.split("_");
    if (!s) continue;
    const c = t[o];
    if (c) {
      if (typeof c == "string")
        e[`${c}_${s}`.toLowerCase()] = e[n];
      else if (Array.isArray(c))
        for (const a of c)
          e[`${a}_${s}`.toLowerCase()] = e[n];
    }
  }
  B.set({ ...e });
}
async function ro(t) {
  const n = await (await fetch(t)).json();
  Bt(n);
}
async function Jo(...t) {
  switch (t.length) {
    case 1:
      return typeof t[0] == "string" ? ro(t[0]) : Bt(t[0]);
    case 2:
      return Bt({ [t[0]]: t[1] });
    default:
      throw new Error("aliasMap expects 1 or 2 arguments, received " + t.length);
  }
}
function Uo(t, e) {
  if (ut(t) == null) {
    N("soundAlias: original sound not found");
    return;
  }
  B.setKey(e, ut(t));
}
function ut(t) {
  return typeof t != "string" ? (console.warn(`getSound: expected string got "${t}". fall back to triangle`), B.get().triangle) : B.get()[t.toLowerCase()];
}
const uo = async () => {
  await navigator.mediaDevices.getUserMedia({ audio: !0 });
  let t = await navigator.mediaDevices.enumerateDevices();
  t = t.filter((n) => n.kind === "audiooutput" && n.deviceId !== "default");
  const e = /* @__PURE__ */ new Map();
  return e.set(vt, ""), t.forEach((n) => {
    e.set(n.label, n.deviceId);
  }), e;
};
let mt = {
  s: "triangle",
  gain: 0.8,
  postgain: 1,
  density: ".03",
  ftype: "12db",
  fanchor: 0,
  resonance: 1,
  hresonance: 1,
  bandq: 1,
  channels: [1, 2],
  phaserdepth: 0.75,
  shapevol: 1,
  distortvol: 1,
  distorttype: 0,
  delay: 0,
  byteBeatExpression: "0",
  delayfeedback: 0.5,
  delaysync: 3 / 16,
  orbit: 1,
  i: 1,
  velocity: 1,
  fft: 8
};
const ho = Object.freeze({ ...mt });
function vo(t, e) {
  mt[t] = e;
}
function Bo() {
  mt = { ...ho };
}
let Et = new Map(Object.entries(mt));
function ke(t, e) {
  Et.set(t, e);
}
function T(t) {
  return Et.get(t);
}
function jo(t) {
  Object.keys(t).forEach((e) => {
    ke(e, t[e]);
  });
}
function po() {
  Et = new Map(Object.entries(mt));
}
function Oo(t) {
  po(), t === "1.0" && ke("fanchor", 0.5);
}
const Eo = () => B.set({});
let Qe = [];
function Do(t) {
  Qe.push(t);
}
let Pt;
function mo() {
  if (!Pt) {
    const t = x(), e = Qe.concat([Tn]);
    Pt = Promise.all(e.map((n) => t.audioWorklet.addModule(n)));
  }
  return Pt;
}
async function bo(t = {}) {
  const {
    disableWorklets: e = !1,
    maxPolyphony: n,
    audioDeviceName: o = vt,
    multiChannelOrbits: s = !1
  } = t;
  if (lo(n), io(s), typeof window > "u")
    return;
  const c = x();
  if (o != null && o != vt)
    try {
      const d = (await uo()).get(o), l = (d ?? "").length > 0;
      c.sinkId !== d && l && await c.setSinkId(d), N(
        `[superdough] Audio Device set to ${o}, it might take a few seconds before audio plays on all output channels`
      );
    } catch {
      N("[superdough] failed to set audio interface", "warning");
    }
  if (await c.resume(), e) {
    N("[superdough]: AudioWorklets disabled with disableWorklets");
    return;
  }
  try {
    await mo(), N("[superdough] AudioWorklets loaded");
  } catch (a) {
    console.warn("could not load AudioWorklet effects", a);
  }
  N("[superdough] ready");
}
let kt;
async function Ao(t) {
  return kt || (kt = new Promise((e) => {
    document.addEventListener("click", async function n() {
      document.removeEventListener("click", n), await bo(t), e();
    });
  })), kt;
}
let gt;
function Je() {
  return gt == null && (gt = new ao(x())), gt;
}
function qo(t, e) {
  Je().output.connectToDestination(t, e);
}
function Zo(t, e, n = 1, o = 0.5, s = 1e3, c = 2e3) {
  const a = x(), d = Tt(a, t, e, { frequency: n, depth: c * 2 }), l = 2;
  let i = 0;
  const r = [];
  for (let u = 0; u < l; u++) {
    const p = a.createBiquadFilter();
    p.type = "notch", p.gain.value = 1, p.frequency.value = s + i, p.Q.value = 2 - Math.min(Math.max(o * 2, 0), 1.9), d.connect(p.detune), i += 282, u > 0 && r[u - 1].connect(p), r.push(p);
  }
  return r[r.length - 1];
}
function Xo(t) {
  t = t ?? 0;
  const e = ["12db", "ladder", "24db"];
  return typeof t == "number" ? e[Math.floor(xe(t, e.length))] : t;
}
let v = {}, ot = {};
function yo(t, e = 1024, n = 0.5) {
  if (!v[t]) {
    const o = x().createAnalyser();
    o.fftSize = e, o.smoothingTimeConstant = n, v[t] = o, ot[t] = new Float32Array(v[t].frequencyBinCount);
  }
  return v[t].fftSize !== e && (v[t].fftSize = e, ot[t] = new Float32Array(v[t].frequencyBinCount)), v[t];
}
function $o(t = "time", e = 1) {
  const n = {
    time: () => v[e]?.getFloatTimeDomainData(ot[e]),
    frequency: () => v[e]?.getFloatFrequencyData(ot[e])
  }[t];
  if (!n)
    throw new Error(`getAnalyzerData: ${t} not supported. use one of ${Object.keys(n).join(", ")}`);
  return n(), ot[e];
}
function _o() {
  gt?.reset(), v = {}, ot = {};
}
let lt = /* @__PURE__ */ new Map();
function ye(t) {
  return (Array.isArray(t) ? t : [t]).map((e) => e - 1);
}
const Go = async (t, e, n, o = 0.5, s = 0.5) => {
  const c = x(), a = Je();
  let { stretch: d } = t;
  if (d != null && (e = e - 0.04), typeof t != "object")
    throw new Error(
      `expected hap.value to be an object, but got "${t}". Hint: append .note() or .s() to the end`,
      "error"
    );
  if (t.duration = n, e < c.currentTime) {
    console.warn(
      `[superdough]: cannot schedule sounds in the past (target: ${e.toFixed(2)}, now: ${c.currentTime.toFixed(2)})`
    );
    return;
  }
  let {
    tremolo: l,
    tremolosync: i,
    tremolodepth: r = 1,
    tremoloskew: u,
    tremolophase: p = 0,
    tremoloshape: h,
    s: m = T("s"),
    bank: b,
    source: X,
    gain: y = T("gain"),
    postgain: Z = T("postgain"),
    density: W = T("density"),
    duckorbit: V,
    duckonset: G,
    duckattack: M,
    duckdepth: L,
    djf: z,
    // filters
    fanchor: S = T("fanchor"),
    drive: R = 0.69,
    release: J = 0,
    // low pass
    cutoff: g,
    lpenv: w,
    lpattack: P,
    lpdecay: A,
    lpsustain: H,
    lprelease: q,
    resonance: U = T("resonance"),
    // high pass
    hpenv: st,
    hcutoff: _,
    hpattack: bt,
    hpdecay: Rt,
    hpsustain: St,
    hprelease: je,
    hresonance: Oe = T("hresonance"),
    // band pass
    bpenv: Ee,
    bandf: Dt,
    bpattack: De,
    bpdecay: Ae,
    bpsustain: qe,
    bprelease: $e,
    bandq: _e = T("bandq"),
    //phaser
    phaserrate: At,
    phaserdepth: qt = T("phaserdepth"),
    phasersweep: tn,
    phasercenter: en,
    //
    coarse: $t,
    crush: _t,
    dry: Zt,
    shape: te,
    shapevol: Nt = T("shapevol"),
    distort: ee,
    distortvol: wt = T("distortvol"),
    distorttype: nn = T("distorttype"),
    pan: ne,
    vowel: oe,
    delay: Xt = T("delay"),
    delayfeedback: ce = T("delayfeedback"),
    delaysync: on = T("delaysync"),
    delaytime: yt,
    orbit: Gt = T("orbit"),
    room: se,
    roomfade: cn,
    roomlp: sn,
    roomdim: an,
    roomsize: dn,
    ir: Yt,
    irspeed: ln,
    irbegin: rn,
    i: ae = T("i"),
    velocity: Ft = T("velocity"),
    analyze: de,
    // analyser wet
    fft: un = T("fft"),
    // fftSize 0 - 10
    compressor: le,
    compressorRatio: hn,
    compressorKnee: pn,
    compressorAttack: mn,
    compressorRelease: bn
  } = t;
  yt = yt ?? zn(on, o);
  const Zn = ye(
    Ie && Gt > 0 ? [Gt * 2 - 1, Gt * 2] : T("channels")
  ), Xn = t.channels != null ? ye(t.channels) : Zn, $ = a.getOrbit(Gt, Xn);
  V != null && a.duck(V, e, G, M, L), y = E(O(y, 1)), Z = E(Z), Nt = E(Nt), wt = E(wt), Xt = E(Xt), Ft = E(Ft), r = E(r), y *= Ft;
  const Vt = e + n, ie = Vt + J, re = Math.round(Math.random() * 1e6);
  for (let f = 0; f <= lt.size - He; f++) {
    const F = lt.entries().next(), Y = F.value[1], xt = F.value[0], ue = e + 0.25;
    Y?.node?.gain?.linearRampToValueAtTime(0, ue), Y?.stop?.(ue), lt.delete(xt);
  }
  let Wt = [];
  if (["-", "~", "_"].includes(m))
    return;
  b && m && (m = `${b}_${m}`, t.s = m);
  let ft;
  if (X)
    ft = X(e, t, n, o);
  else if (ut(m)) {
    const { onTrigger: f } = ut(m), Y = await f(e, t, () => {
      Wt.forEach((xt) => xt?.disconnect()), lt.delete(re);
    }, o);
    Y && (ft = Y.node, lt.set(re, Y));
  } else
    throw new Error(`sound ${m} not found! Is it loaded?`);
  if (!ft)
    return;
  if (c.currentTime > e) {
    N("[webaudio] skip hap: still loading", c.currentTime - e);
    return;
  }
  const K = [];
  K.push(ft), d !== void 0 && K.push(I(c, "phase-vocoder-processor", { pitchFactor: d })), K.push(C(y));
  const Mt = Xo(t.ftype);
  if (g !== void 0) {
    let f = () => Ht(
      c,
      "lowpass",
      g,
      U,
      P,
      A,
      H,
      q,
      w,
      e,
      Vt,
      S,
      Mt,
      R
    );
    K.push(f()), Mt === "24db" && K.push(f());
  }
  if (_ !== void 0) {
    let f = () => Ht(
      c,
      "highpass",
      _,
      Oe,
      bt,
      Rt,
      St,
      je,
      st,
      e,
      Vt,
      S
    );
    K.push(f()), Mt === "24db" && K.push(f());
  }
  if (Dt !== void 0) {
    let f = () => Ht(c, "bandpass", Dt, _e, De, Ae, qe, $e, Ee, e, Vt, S);
    K.push(f()), Mt === "24db" && K.push(f());
  }
  if (oe !== void 0) {
    const f = c.createVowelFilter(oe);
    K.push(f);
  }
  if ($t !== void 0 && K.push(I(c, "coarse-processor", { coarse: $t })), _t !== void 0 && K.push(I(c, "crush-processor", { crush: _t })), te !== void 0 && K.push(I(c, "shape-processor", { shape: te, postgain: Nt })), ee !== void 0 && K.push(Bn(ee, wt, nn)), i != null && (l = o * i), t.wtPosSynced != null && (t.wtPosRate /= o), t.wtWarpSynced != null && (t.wtWarpRate /= o), l !== void 0) {
    const f = Math.max(1 - r, 0), F = new GainNode(c, { gain: f }), Y = s / o;
    Tt(c, e, ie, {
      skew: u ?? (h != null ? 0.5 : 1),
      frequency: l,
      depth: r,
      time: Y,
      dcoffset: 0,
      shape: h,
      phaseoffset: p,
      min: 0,
      max: 1,
      curve: 1.5
    }).connect(F.gain), K.push(F);
  }
  if (le !== void 0 && K.push(
    wn(c, le, hn, pn, mn, bn)
  ), ne !== void 0) {
    const f = c.createStereoPanner();
    f.pan.value = 2 * ne - 1, K.push(f);
  }
  if (At !== void 0 && qt > 0) {
    const f = Zo(e, ie, At, qt, en, tn);
    K.push(f);
  }
  const at = new GainNode(c, { gain: Z });
  if (K.push(at), Xt > 0 && yt > 0 && ce > 0 && ($.getDelay(yt, ce, e), $.sendDelay(at, Xt)), se > 0) {
    let f;
    if (Yt !== void 0) {
      let F, Y = ut(Yt);
      Array.isArray(Y) ? F = Y.data.samples[ae % Y.data.samples.length] : typeof Y == "object" && (F = Object.values(Y.data.samples).flat()[ae % Object.values(Y.data.samples).length]), f = await Ne(F, c, Yt, 0);
    }
    $.getReverb(dn, cn, sn, an, f, ln, rn), $.sendReverb(at, se);
  }
  if (z != null && $.getDjf(z, e), de) {
    const f = yo(de, 2 ** (un + 5)), F = Ut(at, f, 1);
    Wt.push(F);
  }
  if (Zt != null) {
    Zt = E(Zt);
    const f = new GainNode(c, { gain: Zt });
    K.push(f), $.connectToOutput(f);
  } else
    $.connectToOutput(at);
  K.slice(1).reduce((f, F) => f.connect(F), K[0]), Wt = Wt.concat(K);
}, tc = (t, e, n, o) => {
  Go(e, t - n, e.duration / o, o);
}, Vo = ["triangle", "square", "sawtooth", "sine"], Wo = [
  ["tri", "triangle"],
  ["sqr", "square"],
  ["saw", "sawtooth"],
  ["sin", "sine"]
];
function fo(t, e) {
  const n = t, o = new Float32Array(e);
  for (let s = 0; s < e; s++) {
    const c = s * 2 / e - 1;
    o[s] = Math.tanh(c * n);
  }
  return o;
}
function ec() {
  [...Vo].forEach((t) => {
    j(
      t,
      (e, n, o) => {
        const [s, c, a, d] = Q(
          [n.attack, n.decay, n.sustain, n.release],
          "linear",
          [1e-3, 0.05, 0.6, 0.01]
        );
        let l = xo(t, e, n), { node: i, stop: r, triggerRelease: u } = l;
        const p = C(0.3), { duration: h } = n;
        i.onended = () => {
          i.disconnect(), p.disconnect(), o();
        };
        const m = C(1);
        let b = i.connect(p).connect(m);
        const X = e + h;
        k(b.gain, s, c, a, d, 0, 1, e, X, "linear");
        const y = X + d + 0.01;
        return u?.(y), r(y), {
          node: b,
          stop: (Z) => {
            r(Z);
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  }), j(
    "sbd",
    (t, e, n) => {
      const { duration: o, decay: s = 0.5, pdecay: c = 0.5, penv: a = 36, clip: d } = e, l = x(), i = 0.02, r = 1.2, u = 0.025, p = 1, h = l.createOscillator();
      h.type = "triangle", h.frequency.value = et(e, 29), h.detune.setValueAtTime(a * 100, 0), h.detune.setValueAtTime(a * 100, t), h.detune.exponentialRampToValueAtTime(1e-3, t + c);
      const m = C(1);
      m.gain.setValueAtTime(1, t + i), m.gain.exponentialRampToValueAtTime(1e-3, t + i + s), h.start(t);
      const b = Jt("brown", t, 2), X = C(1);
      X.gain.setValueAtTime(r, t), X.gain.exponentialRampToValueAtTime(1e-3, t + u);
      const y = new WaveShaperNode(l);
      y.curve = fo(2, l.sampleRate);
      const Z = C(p);
      h.onended = () => {
        h.disconnect(), m.disconnect(), y.disconnect(), b.node.disconnect(), X.disconnect(), Z.disconnect(), n();
      };
      const W = h.connect(y).connect(m).connect(Z);
      b.node.connect(X).connect(Z);
      let G = t + s + 0.01;
      return d != null && (G = Math.min(t + d * o, G)), Z.gain.setValueAtTime(p, G - 0.01), Z.gain.linearRampToValueAtTime(0, G), h.stop(G), b.stop(G), {
        node: W,
        stop: (M) => {
          h.stop(M);
        }
      };
    },
    { type: "synth", prebake: !0 }
  ), j(
    "supersaw",
    (t, e, n) => {
      const o = x();
      let { duration: s, n: c, unison: a = 5, spread: d = 0.6, detune: l } = e;
      l = l ?? c ?? 0.18;
      const i = et(e), [r, u, p, h] = Q(
        [e.attack, e.decay, e.sustain, e.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), m = t + s, b = m + h + 0.01, X = D(a, 1, 100);
      let y = X > 1 ? D(d, 0, 1) : 0, Z = I(
        o,
        "supersaw-oscillator",
        {
          frequency: i,
          begin: t,
          end: b,
          freqspread: l,
          voices: X,
          panspread: y
        },
        {
          outputChannelCount: [2]
        }
      );
      const W = 1 / Math.sqrt(X);
      ht(Z.parameters.get("detune"), e, t, m);
      const V = pt(Z.parameters.get("detune"), e, t), G = Kt(Z.parameters.get("frequency"), e, t);
      let M = C(1);
      M = Z.connect(M), k(M.gain, r, u, p, h, 0, 0.3 * W, t, m, "linear");
      let L = rt(
        o,
        () => {
          it(Z), M.disconnect(), n(), G?.stop(), V?.stop();
        },
        t,
        b
      );
      return {
        node: M,
        stop: (z) => {
          L.stop(z);
        }
      };
    },
    { prebake: !0, type: "synth" }
  ), j(
    "bytebeat",
    (t, e, n) => {
      const o = [
        "(t%255 >= t/255%255)*255",
        "(t*(t*8%60 <= 300)|(-t)*(t*4%512 < 256))+t/400",
        "t",
        "t*(t >> 10^t)",
        "t&128",
        "t&t>>8",
        "((t%255+t%128+t%64+t%32+t%16+t%127.8+t%64.8+t%32.8+t%16.8)/3)",
        "((t%64+t%63.8+t%64.15+t%64.35+t%63.5)/1.25)",
        "(t&(t>>7)-t)",
        "(sin(t*PI/128)*127+127)",
        "((t^t/2+t+64*(sin((t*PI/64)+(t*PI/32768))+64))%128*2)",
        "((t^t/2+t+64*(cos >> 0))%127.85*2)",
        "((t^t/2+t+64)%128*2)",
        "(((t * .25)^(t * .25)/100+(t * .25))%128)*2",
        "((t^t/2+t+64)%7 * 24)"
      ], { n: s = 0 } = e, c = et(e), { byteBeatExpression: a = o[s % o.length], byteBeatStartTime: d } = e, l = x();
      let { duration: i } = e;
      const [r, u, p, h] = Q(
        [e.attack, e.decay, e.sustain, e.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), m = t + i, b = m + h + 0.01;
      let X = I(
        l,
        "byte-beat-processor",
        {
          frequency: c,
          begin: t,
          end: b
        },
        {
          outputChannelCount: [2]
        }
      );
      X.port.postMessage({ codeText: a, byteBeatStartTime: d, frequency: c });
      let y = C(1);
      y = X.connect(y), k(y.gain, r, u, p, h, 0, 1, t, m, "linear");
      let Z = rt(
        l,
        () => {
          it(X), y.disconnect(), n();
        },
        t,
        b
      );
      return {
        node: y,
        stop: (W) => {
          Z.stop(W);
        }
      };
    },
    { prebake: !0, type: "synth" }
  ), j(
    "pulse",
    (t, e, n) => {
      const o = x();
      let { pwrate: s, pwsweep: c } = e;
      c == null && (s != null ? c = 0.3 : c = 0), s == null && c != null && (s = 1);
      let { duration: a, pw: d = 0.5 } = e;
      const l = et(e), [i, r, u, p] = Q(
        [e.attack, e.decay, e.sustain, e.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), h = t + a, m = h + p + 0.01;
      let b = I(
        o,
        "pulse-oscillator",
        {
          frequency: l,
          begin: t,
          end: m,
          pulsewidth: d
        },
        {
          outputChannelCount: [2]
        }
      );
      ht(b.parameters.get("detune"), e, t, h);
      const X = pt(b.parameters.get("detune"), e, t), y = Kt(b.parameters.get("frequency"), e, t);
      let Z = C(1);
      Z = b.connect(Z), k(Z.gain, i, r, u, p, 0, 1, t, h, "linear");
      let W;
      c != 0 && (W = Tt(o, t, m, { frequency: s, depth: c }), W.connect(b.parameters.get("pulsewidth")));
      let V = rt(
        o,
        () => {
          it(b), it(W), Z.disconnect(), n(), y?.stop(), X?.stop();
        },
        t,
        m
      );
      return {
        node: Z,
        stop: (G) => {
          V.stop(G);
        }
      };
    },
    { prebake: !0, type: "synth" }
  ), [...Ke].forEach((t) => {
    j(
      t,
      (e, n, o) => {
        const [s, c, a, d] = Q(
          [n.attack, n.decay, n.sustain, n.release],
          "linear",
          [1e-3, 0.05, 0.6, 0.01]
        );
        let l, { density: i } = n;
        l = Jt(t, e, i);
        let { node: r, stop: u, triggerRelease: p } = l;
        const h = C(0.3), { duration: m } = n;
        r.onended = () => {
          r.disconnect(), h.disconnect(), o();
        };
        const b = C(1);
        let X = r.connect(h).connect(b);
        const y = e + m;
        k(X.gain, s, c, a, d, 0, 1, e, y, "linear");
        const Z = y + d + 0.01;
        return p?.(Z), u(Z), {
          node: X,
          stop: (W) => {
            u(W);
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  }), Wo.forEach(([t, e]) => B.set({ ...B.get(), [t]: B.get()[e] }));
}
function Mo(t, e) {
  const n = new Float32Array(t + 1), o = new Float32Array(t + 1), s = x(), c = s.createOscillator(), a = {
    sawtooth: (i) => [0, -1 / i],
    square: (i) => [0, i % 2 === 0 ? 0 : 1 / i],
    triangle: (i) => [i % 2 === 0 ? 0 : 1 / (i * i), 0]
  };
  if (!a[e])
    throw new Error(`unknown wave type ${e}`);
  n[0] = 0, o[0] = 0;
  let d = 1;
  for (; d <= t; ) {
    const [i, r] = a[e](d);
    n[d] = i, o[d] = r, d++;
  }
  const l = s.createPeriodicWave(n, o);
  return c.setPeriodicWave(l), c;
}
function xo(t, e, n) {
  let { n: o, duration: s, noise: c = 0 } = n, a;
  !o || t === "sine" ? (a = x().createOscillator(), a.type = t || "triangle") : a = Mo(o, t), a.frequency.value = et(n), a.start(e);
  let d = pt(a.detune, n, e);
  ht(a.detune, n, e, e + s);
  const l = Kt(a.frequency, n, e);
  let i;
  return c && (i = Sn(a, c, e)), {
    node: i?.node || a,
    stop: (r) => {
      l.stop(r), d?.stop(r), i?.stop(r), a.stop(r);
    },
    triggerRelease: (r) => {
    }
  };
}
function go(t = 1, e = 0.05, n = 220, o = 0, s = 0, c = 0.1, a = 0, d = 1, l = 0, i = 0, r = 0, u = 0, p = 0, h = 0, m = 0, b = 0, X = 0, y = 1, Z = 0, W = 0) {
  let V = Math.PI * 2, G = x().sampleRate, M = (st) => st > 0 ? 1 : -1, L = l *= 500 * V / G / G, z = n *= (1 + e * 2 * Math.random() - e) * V / G, S = [], R = 0, J = 0, g = 0, w = 1, P = 0, A = 0, H = 0, q, U;
  for (o = o * G + 9, Z *= G, s *= G, c *= G, X *= G, i *= 500 * V / G ** 3, m *= V / G, r *= V / G, u *= G, p = p * G | 0, U = o + Z + s + c + X | 0; g < U; S[g++] = H)
    ++A % (b * 100 | 0) || (H = a ? a > 1 ? a > 2 ? a > 3 ? Math.sin((R % V) ** 3) : Math.max(Math.min(Math.tan(R), 1), -1) : 1 - (2 * R / V % 2 + 2) % 2 : 1 - 4 * Math.abs(Math.round(R / V) - R / V) : Math.sin(R), H = (p ? 1 - W + W * Math.sin(V * g / p) : 1) * M(H) * Math.abs(H) ** d * // curve 0=square, 2=pointy
    t * 1 * // envelope
    (g < o ? g / o : g < o + Z ? 1 - (g - o) / Z * (1 - y) : g < o + Z + s ? y : g < U - X ? (U - g - X) / c * // release falloff
    y : 0), H = X ? H / 2 + (X > g ? 0 : (g < U - X ? 1 : (U - g) / X) * // release delay
    S[g - X | 0] / 2) : H), q = (n += l += i) * // frequency
    Math.cos(m * J++), R += q - q * h * (1 - (Math.sin(g) + 1) * 1e9 % 2), w && ++w > u && (n += r, z += r, w = 0), p && !(++P % p) && (n = z, l = L, w ||= 1);
  return S;
}
const Lo = (t, e) => {
  let {
    s: n,
    note: o = 36,
    freq: s,
    //
    zrand: c = 0,
    attack: a = 0,
    decay: d = 0,
    sustain: l = 0.8,
    release: i = 0.1,
    curve: r = 1,
    slide: u = 0,
    deltaSlide: p = 0,
    pitchJump: h = 0,
    pitchJumpTime: m = 0,
    lfo: b = 0,
    znoise: X = 0,
    zmod: y = 0,
    zcrush: Z = 0,
    zdelay: W = 0,
    tremolo: V = 0,
    duration: G = 0.2,
    zzfx: M
  } = t;
  const L = Math.max(G - a - d, 0);
  typeof o == "string" && (o = zt(o)), !s && typeof o == "number" && (s = Me(o)), n = n.replace("z_", "");
  const z = ["sine", "triangle", "sawtooth", "tan", "noise"].indexOf(n) || 0;
  r = n === "square" ? 0 : r;
  const R = (
    /* ZZFX. */
    go(...M || [
      0.25,
      // volume
      c,
      s,
      a,
      L,
      i,
      z,
      r,
      u,
      p,
      h,
      m,
      b,
      X,
      y,
      Z,
      W,
      l,
      // sustain volume!
      d,
      V
    ])
  ), J = x(), g = J.createBuffer(1, R.length, J.sampleRate);
  g.getChannelData(0).set(R);
  const w = x().createBufferSource();
  return w.buffer = g, w.start(e), {
    node: w
  };
};
function nc() {
  ["zzfx", "z_sine", "z_sawtooth", "z_triangle", "z_square", "z_tan", "z_noise"].forEach((t) => {
    j(
      t,
      (e, n, o) => {
        const { node: s } = Lo({ s: t, ...n }, e);
        return s.onended = () => {
          s.disconnect(), o();
        }, {
          node: s,
          stop: () => {
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  });
}
let ct;
async function Ko(t, e) {
  const n = `dsp-worklet-${Date.now()}`, o = `${e}
let __q = []; // trigger queue
class MyProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.t = 0;
    this.stopped = false;
    this.port.onmessage = (e) => {
      if(e.data==='stop') {
        this.stopped = true;
      } else if(e.data?.dough) {
        __q.push(e.data)
      } else {
        msg?.(e.data)
      }
    };
  }
  process(inputs, outputs, parameters) {
    const output = outputs[0];
    if(__q.length) {
      for(let i=0;i<__q.length;++i) {
        const deadline = __q[i].time-currentTime;
        if(deadline<=0) {
          trigger(__q[i].dough)
          __q.splice(i,1)
        }
      }
    }
    for (let i = 0; i < output[0].length; i++) {
      const out = dsp(this.t / sampleRate);
      output.forEach((channel) => {
        channel[i] = out;
      });
      this.t++;
    }
  return !this.stopped;
  }
}
registerProcessor('${n}', MyProcessor);
`, c = `data:text/javascript;base64,${btoa(o)}`;
  await t.audioWorklet.addModule(c);
  const a = new AudioWorkletNode(t, n);
  return { node: a, stop: () => a.port.postMessage("stop") };
}
const Ue = () => {
  ct && (ct?.stop(), ct?.node?.disconnect());
};
typeof window < "u" && window.addEventListener("message", (t) => {
  t.data === "strudel-stop" ? Ue() : t.data?.dough && ct?.node.port.postMessage(t.data);
});
const oc = async (t) => {
  const e = x();
  Ue(), ct = await Ko(e, t), ct.node.connect(e.destination);
};
function cc(t, e, n, o) {
  window.postMessage({ time: o, dough: t.value, currentTime: e, duration: t.duration, cps: n });
}
const Ge = Object.freeze({
  NONE: 0,
  ASYM: 1,
  MIRROR: 2,
  BENDP: 3,
  BENDM: 4,
  BENDMP: 5,
  SYNC: 6,
  QUANT: 7,
  FOLD: 8,
  PWM: 9,
  ORBIT: 10,
  SPIN: 11,
  CHAOS: 12,
  PRIMES: 13,
  BINARY: 14,
  BROWNIAN: 15,
  RECIPROCAL: 16,
  WORMHOLE: 17,
  LOGISTIC: 18,
  SIGMOID: 19,
  FRACTAL: 20,
  FLIP: 21
}), Ve = /* @__PURE__ */ new Set();
async function zo(t, e, n = 2048) {
  const o = `${t},${n}`;
  if (!Ve.has(o)) {
    const c = (await No(t, e)).getChannelData(0), a = c.length, d = Math.max(1, Math.floor(a / n)), l = new Array(d);
    for (let i = 0; i < d; i++) {
      const r = i * n;
      l[i] = c.subarray(r, r + n);
    }
    return Ve.add(o), { frames: l, frameLen: n, numFrames: d, key: o };
  }
  return { frameLen: n, key: o };
}
function To(t, e) {
  var n = 1024;
  if (t < n) return t + " B";
  var o = ["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], s = -1;
  do
    t /= n, ++s;
  while (t >= n);
  return t.toFixed(1) + " " + o[s];
}
function Ro(t) {
  const e = new DataView(t);
  let n = 12;
  for (; n + 8 <= e.byteLength; ) {
    const o = String.fromCharCode(e.getUint8(n), e.getUint8(n + 1), e.getUint8(n + 2), e.getUint8(n + 3)), s = e.getUint32(n + 4, !0);
    if (o === "fmt ")
      return e.getUint32(n + 12, !0);
    n += 8 + s + (s & 1);
  }
  return null;
}
async function So(t) {
  const e = Ro(t) || 44100;
  return await new OfflineAudioContext(1, 1, e).decodeAudioData(t);
}
const Qt = {}, No = (t, e) => {
  if (t = t.replace("#", "%23"), !Qt[t]) {
    N(`[wavetable] load table ${e}..`, "load-table", { url: t });
    const n = Date.now();
    Qt[t] = fetch(t).then((o) => o.arrayBuffer()).then(async (o) => {
      const s = Date.now() - n, c = To(o.byteLength);
      return N(`[wavetable] load table ${e}... done! loaded ${c} in ${s}ms`, "loaded-table", { url: t }), await So(o);
    });
  }
  return Qt[t];
};
function ve(t, e = "") {
  if (!t.startsWith("github:"))
    throw new Error('expected "github:" at the start of pseudoUrl');
  let [n, o] = t.split("github:");
  return o = o.endsWith("/") ? o.slice(0, -1) : o, o.split("/").length === 2 && (o += "/main"), `https://raw.githubusercontent.com/${o}/${e}`;
}
const We = (t, e, n, o = {}) => (e = t._base || e, Object.entries(t).forEach(([s, c]) => {
  if (s === "_base") return !1;
  if (typeof c == "string" && (c = [c]), typeof c != "object")
    throw new Error("wrong json format for " + s);
  let a = e;
  a.startsWith("github:") && (a = ve(a, "")), c = c.map((d) => a + d).filter((d) => d.toLowerCase().endsWith(".wav") ? !0 : (N(`[wavetable] skipping ${d} -- wavetables must be ".wav" format`), !1)), c.length && Be(s, c, { baseUrl: e, frameLen: n });
}));
function Be(t, e, n) {
  j(
    t,
    (o, s, c, a) => wo(o, s, c, e, a, n?.frameLen ?? 2048),
    {
      type: "wavetable",
      tables: e,
      ...n
    }
  );
}
const sc = async (t, e, n, o = {}) => {
  if (n !== void 0) return We(n, t, e);
  if (t.startsWith("github:") && (t = ve(t, "strudel.json")), t.startsWith("local:") && (t = "http://localhost:5432"), typeof fetch == "function" && !(typeof fetch > "u"))
    return fetch(t).then((s) => s.json()).then((s) => We(s, t, e, o)).catch((s) => {
      throw console.error(s), new Error(`error loading "${t}"`);
    });
};
async function wo(t, e, n, o, s, c) {
  const { s: a, n: d = 0, duration: l, clip: i } = e, r = x(), [u, p, h, m] = Q([e.attack, e.decay, e.sustain, e.release]);
  let { warpmode: b } = e;
  typeof b == "string" && (b = Ge[b.toUpperCase()] ?? Ge.NONE);
  const X = et(e), { url: y, label: Z } = ge(e, o), W = await zo(y, Z, c);
  let V = t + l;
  i !== void 0 && (V = Math.min(t + i * l, V));
  const G = V + m, M = G + 0.01, L = I(
    r,
    "wavetable-oscillator-processor",
    {
      begin: t,
      end: M,
      frequency: X,
      freqspread: e.detune,
      position: e.wt,
      warp: e.warp,
      warpMode: b,
      voices: Math.max(e.unison ?? 1, 1),
      panspread: e.spread,
      phaserand: e.wtphaserand ?? e.unison > 1 ? 1 : 0
    },
    { outputChannelCount: [2] }
  );
  if (L.port.postMessage({ type: "table", payload: W }), r.currentTime > t) {
    N(`[wavetable] still loading sound "${a}:${d}"`, "highlight");
    return;
  }
  const z = [e.wtattack, e.wtdecay, e.wtsustain, e.wtrelease], S = [e.warpattack, e.warpdecay, e.warpsustain, e.warprelease], R = L.parameters, J = R.get("position"), g = R.get("warp");
  let w = e.wtrate;
  e.wtsync != null && (w = s * e.wtsync);
  const P = be(
    r,
    J,
    t,
    G,
    {
      offset: e.wt,
      amount: e.wtenv,
      defaultAmount: 0.5,
      shape: "linear",
      values: z,
      holdEnd: V,
      defaultValues: [0, 0.5, 0, 0.1]
    },
    {
      frequency: w,
      depth: e.wtdepth,
      defaultDepth: 0.5,
      shape: e.wtshape,
      skew: e.wtskew,
      dcoffset: e.wtdc ?? 0
    }
  );
  let A = e.warprate;
  e.warpsync != null && (A = A = s * e.warpsync);
  const H = be(
    r,
    g,
    t,
    G,
    {
      offset: e.warp,
      amount: e.warpenv,
      defaultAmount: 0.5,
      shape: "linear",
      values: S,
      holdEnd: V,
      defaultValues: [0, 0.5, 0, 0.1]
    },
    {
      frequency: A,
      depth: e.warpdepth,
      defaultDepth: 0.5,
      shape: e.warpshape,
      skew: e.warpskew,
      dcoffset: e.warpdc ?? 0
    }
  ), q = pt(L.parameters.get("detune"), e, t), U = Kt(L.parameters.get("frequency"), e, t), st = r.createGain(), _ = L.connect(st);
  k(_.gain, u, p, h, m, 0, 0.3, t, V, "linear"), ht(L.parameters.get("detune"), e, t, V);
  const bt = { node: _, source: L }, Rt = rt(
    r,
    () => {
      it(L), q?.stop(), U?.stop(), _.disconnect(), P?.disconnect(), H?.disconnect(), n();
    },
    t,
    M
  );
  return bt.stop = (St) => {
    Rt.stop(St);
  }, bt;
}
export {
  Ce as DEFAULT_MAX_POLYPHONY,
  Ge as Warpmode,
  Jo as aliasBank,
  v as analysers,
  ot as analysersData,
  Kt as applyFM,
  E as applyGainCurve,
  be as applyParameterModulators,
  qo as connectToDestination,
  Ht as createFilter,
  it as destroyAudioWorkletNode,
  Se as distortionAlgorithms,
  oc as dough,
  cc as doughTrigger,
  Yn as drywet,
  Ko as dspWorklet,
  Ut as effectSend,
  fn as errorLogger,
  _n as fetchSampleMap,
  C as gainNode,
  Q as getADSRValues,
  yo as getAnalyserById,
  $o as getAnalyzerData,
  x as getAudioContext,
  Co as getAudioContextCurrentTime,
  uo as getAudioDevices,
  Io as getCachedBuffer,
  wn as getCompressor,
  T as getDefaultValue,
  Bn as getDistortion,
  Ho as getDistortionAlgorithm,
  et as getFrequencyFromValue,
  Tt as getLfo,
  Po as getLoadedBuffer,
  xo as getOscillator,
  k as getParamADSR,
  ht as getPitchEnvelope,
  En as getSampleBuffer,
  Dn as getSampleBufferSource,
  On as getSampleInfo,
  ut as getSound,
  pt as getVibratoOscillator,
  I as getWorklet,
  Lo as getZZFX,
  bo as initAudio,
  Ao as initAudioOnFirstClick,
  Ne as loadBuffer,
  N as logger,
  Ke as noises,
  eo as onTriggerSample,
  wo as onTriggerSynth,
  qn as processSampleMap,
  oo as registerSampleSource,
  ko as registerSamplesPrefix,
  j as registerSound,
  ec as registerSynthSounds,
  Be as registerWaveTable,
  Do as registerWorklet,
  nc as registerZZFXSounds,
  po as resetDefaultValues,
  Bo as resetDefaults,
  _o as resetGlobalEffects,
  Eo as resetLoadedSounds,
  An as reverseBuffer,
  to as samples,
  vo as setDefault,
  Rn as setDefaultAudioContext,
  ke as setDefaultValue,
  jo as setDefaultValues,
  Qo as setGainCurve,
  Fo as setLogger,
  lo as setMaxPolyphony,
  io as setMultiChannelOrbits,
  Oo as setVersionDefaults,
  Uo as soundAlias,
  B as soundMap,
  Go as superdough,
  tc as superdoughTrigger,
  sc as tables,
  Mo as waveformN,
  rt as webAudioTimeout
};
